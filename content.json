{"meta":{"title":"Eathl的储物间","subtitle":"","description":"Eathl的储物间","author":"Eathl","url":"https://eathl.github.io","root":"/"},"pages":[],"posts":[{"title":"CSS高频面试题","slug":"CSS面试题","date":"2023-06-01T02:53:17.940Z","updated":"2023-06-01T02:53:33.836Z","comments":true,"path":"2023/06/01/CSS面试题/","link":"","permalink":"https://eathl.github.io/2023/06/01/CSS%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"01. 盒模型宽度计算在如下代码中类名为 box 的 div，它的 offsetWidth 是多少? &lt;style&gt; #box &#123; width: 100px; padding: 10px; border: 1px solid skyblue; margin: 10px; &#125; &lt;/style&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; console.log(document.getElementById(&quot;box&quot;).offsetWidth); &lt;/script&gt; offsetWidth &#x3D; 内容宽度 + 内边距 + 边框 box 的内容宽度为 100、左右内边距各为 10、左右边框各为 1、所以盒子的 offsetWidth 为 122。 通过 box-sizing 可以设置到底要如何计算一个元素的总宽度和总高度。 它的默认值为 content-box，即指定 width 属性值为内容宽度，盒子的实际宽度为内容宽度 + 内边距 + 边框。 它的值也可以是 border-box，即指定 width 属性值为盒子的总宽度，在设置了内边距和边框的情况下会挤压盒子内容的宽度。 02. 外边距负值外边距在四个方向上设置负值会产生什么效果。 margin-top 设置正值元素向下移动、设置负值向上移动。 margin-left 设置正值元素向右移动、设置负值向左移动。 margin-right 设置正值右侧元素向右移动、设置负值右侧元素向左移动。 margin-bottom 设置正值下方元素向下移动，设置负值下方元素向上移动。 &lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; display: inline-block; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; display: inline-block; vertical-align: top; //行内块有基线对齐特性 &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 03. 外边距重叠① 什么是外边距重叠 两个块级元素的上外边距和下外边距可能会合并为一个外边距，这种现象被称之为外边距重叠。 外边距重叠只发生在垂直方向，水平方向不会重叠。浮动的元素和绝对定位的元素的外边距不会折叠。 ② 外边距重叠的计算方式 (1) 如果两者都是正数，取最大值为最终的外边距值。 &lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 30px; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; (2) 如果两者一正一负，使用正值减去负值的绝对值，得到的结果为最终的外边距值。 &lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: -10px; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; (3) 如果两者都是负值，使用 0 减去两个中值中绝对值大的那个，得到的结果为最终的外边距值 &lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: -20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: -10px; &#125; &lt;/style&gt; ③ 如何解决外边距重叠 (1) 不要同时为两个相邻的块级元素同时设置垂直方向上的边距(推荐) (2) 为下层元素设置浮动或定位(绝对定位、固定定位)或 inline-block 04. 外边距塌陷① 什么是外边距塌陷 两个嵌套关系的(一般为父子关系)块元素，当父元素有上外边距子元素也有上外边距时，两个上外边距会合成一个上外边距。 &lt;style&gt; body &#123; margin: 0; &#125; .box1 &#123; width: 100px; background: skyblue; margin-top: 10px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 10px; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; ② 如何解决外边距塌陷 (1) 为父元素设置 overflow: auto&#x2F;hidden (2) 为父元素设置浮动 (3) 为父元素设置 display: inline-block (4) 为父元素设置 border: 1px solid transparent (5) 为父元素设置 padding: 1px 05. 清除浮动子元素浮动后父元素高度撑不开的问题如何解决 &lt;style&gt; .parent &#123; width: 100%; background: skyblue; &#125; .item &#123; width: 200px; height: 100px; background: purple; float: left; &#125; &lt;/style&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; ① 为父级元素添加 overflow: hidden 或 overflow: auto .parent &#123; overflow: hidden; &#125; ② 通过伪类元素解决浮动父级元素高度问题 .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125; &lt;div class=&quot;parent clearfix&quot;&gt;&lt;/div&gt; 06. 理解 BFC① 什么是 BFC BFC 全称 Block Formatting Context， 意为块级格式化上下文。 BFC 其实就是指一块能够独立渲染的区域，并对这块区域内部的块级元素如何布局进行了规定。(如何布局都不会影响到外部，也不受外部影响) 比如块级元素默认在盒子的左上角进行渲染、块级盒子独占一行垂直排列、块级盒子之间的间距由 margin 设置。 由于通过 BFC 产生了一块独立渲染的区域，所以该区域内的元素无论怎样布局都不会影响到区域以外的元素。 只有块级元素可以具备 BFC 特性。 通过理解和 BFC 相关的知识能够对布局过程中产生问题进行快速解决，比如外边距重叠、外边距塌陷、浮动父级高度无法撑开等问题。 ② 如何使元素具有 BFC 特性 (1) 根元素(HTML) (2) 浮动之后的元素(float 属性的值不为 none) (3) 绝对定位和固定定位之后的元素 (4) 行内块元素 (5) 表格单元格(display: table-cell)、表格标题(display: table-caption) (6) overflow 属性值不为 visible 的块元素 (7) 弹性盒元素(display: flex) (8) 网格元素 (display: grid) ③ BFC 特性 在同一个 BFC 中相邻的两个块级元素垂直方向上的外边距会被折叠 BFC 盒子的不会与浮动盒子产生交集而是紧贴着浮动元素的边缘 计算 BFC 盒子的高度时也会检测浮动盒子的高度 解决外边距塌陷，可以在子盒子box2的外边加一个父级元素，父级元素设置 overflow:hidden，触发BFC 特性，使之成为一块独立渲染的区域，由于它变成了独立的渲染区域，区域内的任何布局不会影响到外部，所以自然就不会外边距塌陷了。这就是使用 BFC 解决 margin 塌陷的方式 &lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 30px; &#125; .parent &#123; overflow: hidden; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; 07. 圣杯布局① 什么是圣杯布局 圣杯布局是指三栏布局，左右两栏宽度固定、中间宽度自适应。 在圣杯布局中要求中间一栏最先加载出来。 ② 实现圣杯布局 &lt;style&gt; body &#123; margin: 0; &#125; .container &#123; padding: 0 150px 0 200px; &#125; .column &#123; float: left; &#125; .left &#123; width: 200px; background: skyblue; margin-left: -100%; //百分比 相对于父盒子的宽度 position: relative; left: -200px; //自身宽度 &#125; .center &#123; width: 100%; background: purple; &#125; .right &#123; width: 150px; background: palegreen; margin-left: -150px; //自身宽度 position: relative; left: 150px; //自身宽度 &#125; .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125; &lt;/style&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;center column&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt; &lt;/div&gt; 08. 双飞翼布局① 什么是双飞翼布局 双飞翼布局和圣杯布局一样都是要实现三栏布局，两侧栏宽度固定，中间栏宽度自适应。 ② 实现双飞翼布局 &lt;style&gt; body &#123; margin: 0; &#125; .main-wrap &#123; width: 100%; background: purple; &#125; .main &#123; margin: 0 150px 0 200px; &#125; .column &#123; float: left; &#125; .left &#123; width: 200px; background: skyblue; margin-left: -100%; &#125; .center &#123; width: 100%; &#125; .right &#123; width: 150px; background: palegreen; margin-left: -150px; &#125; .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125; &lt;/style&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;main-wrap column&quot;&gt; &lt;div class=&quot;main&quot;&gt;center&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt; &lt;/div&gt; 09. 弹性盒布局&lt;style&gt; .container &#123; width: 1200px; height: 500px; border: 2px solid #000; &#125; .item &#123; width: 200px; height: 100px; &#125; .item_1 &#123; background: skyblue; &#125; .item_2 &#123; background: purple; &#125; .item_3 &#123; background: orangered; &#125; &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item_1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item_2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item_3&quot;&gt;&lt;/div&gt; &lt;/div&gt; .container &#123; /* 通过 display: flex 将 container 设置为弹性容器 container 的直接一级子元素自动成为弹性盒子 弹性盒子默认按照主轴方向进行排列, 而主轴方向默认又是水平的, 从左到右 所以当 container 被设置为弹性容器以后, 弹性盒子自动在水平方向上从左到右排列 */ display: flex; &#125; .container &#123; /* 通过 justify-content 可以设置弹性盒子在主轴方向上的对应方式 flex-start: 左对齐 flex-end: 右对齐 center: 居中对齐 space-between: 盒子与盒子之间平均分配空间(不包含第一个盒子的左边和最后一个盒子的右边) space-evenly: 在盒子与盒子之间凭据分配间距(包含第一个盒子的左边和最后一个盒子的右边) space-around: 在盒子的两边凭据分配间距 */ justify-content: space-around; &#125; .container &#123; /* 通过 align-items 可以设置弹性盒子在侧轴方向上的对齐方式 flex-start: 顶对齐 flex-end: 底对齐 center: 垂直居中对齐 stretch: 在弹性盒没有高度的情况下 让弹性盒的高度撑满父级 */ align-items: center; &#125; .container &#123; align-items: center; &#125; .item_3 &#123; /* 通过 align-self 属性可以单独设置某一个弹性盒子的侧轴方向上的对齐方式 */ align-self: flex-end; &#125; .container &#123; /* 设置弹性盒子在主轴方向上左对齐 */ justify-content: flex-start; &#125; .item_3 &#123; /* 通过 margin auto 可以单独设置某一个弹性盒子在主轴方向上位置 */ /* 将第三个盒子推向最右侧 */ margin-left: auto; &#125; .item_2 &#123; /* 当父级有剩余空间时, 通过扩展当前元素的宽度占据所有剩余空间 */ flex-grow: 1; &#125; /* 将父级剩余空间划分为4分, 通过扩展弹性盒子占据剩余空间, item_1, item_3 占四分之一, item_2 占四分之二*/ .item_1 &#123; flex-grow: 1; &#125; .item_2 &#123; flex-grow: 2; &#125; .item_3 &#123; flex-grow: 1; &#125; .container &#123; width: 1200px; &#125; .item &#123; width: 500px; &#125; /* 当父级宽度不足以放置所有弹性盒子时, 所有弹性盒子的宽度默认会被缩减, 直到父级可以放置所有弹性盒子 */ .item_1 &#123; /* 通过 flex-shrink 属性可以改变盒子缩减行为, 它的默认值为1, 即每个盒子的缩减比例一致 可以将 flex-shrink 属性的值设置为 0, 表示不缩减当前盒子, 增加其他盒子的缩减比例 */ flex-shrink: 0; &#125; .item &#123; width: 500px; flex-shrink: 0; &#125; .container &#123; /* 当弹性容器的宽度不够时, 可以通过设置 flex-wrap: wrap 让弹性盒子换行显示 */ flex-wrap: wrap; &#125; .container &#123; /* 通过 align-content 属性可以设置弹性盒子的行对齐方式 */ align-content: flex-start; &#125; /* 通过 order 属性可以调整元素的显示顺序 */ .item_1 &#123; order: 3; &#125; .item_2 &#123; order: 1; &#125; .item_3 &#123; order: 2; &#125; .container &#123; /* 通过设置 flex-direction 属性可以调整主轴方向, 默认值为 row, 即主轴方向为水平, 盒子从左到右排列 flex-direction: column 设置主轴方向为垂直, 盒子从上到下排列 flex-direction: column-reverse 设置主轴方向为垂直, 盒子从下到上排列 flex-direction: row-reverse 设置主轴方向为水平, 盒子从右到左排列 */ flex-direction: column; /* 设置盒子在主轴方向居中对齐 (垂直) */ justify-content: center; /* 设置盒子在侧轴方向居中对齐 (水平) */ align-items: center; &#125; 10. 定位&lt;style&gt; /* 定位是指确定元素的位置 元素位置的调整可以有不同的参数对象 可以参数自身, 可以参考有定位的父级, 可以参数浏览器窗口 css 中可以通过 position 属性来确认元素位置调整时的参数对象 */ /* 静态定位 position: static; 元素在不设置定位时, 元素的 position 属性值就是 static 一般在使用它时都是在取消该元素的其他定位特性. */ /* 相对定位 position: relative 相对定位的元素是相对于元素自身在文档流中原本的位置进行定位 采用相对定位的元素没有脱离文档流, 所以当相对定位的元素被调整位置时, 原有位置会被保留, 不会影响文档流中的其他元素的位置 一般在进行网页布局时, 极少改变相对定位元素的位置 极大多数情况下, 相对定位的元素都是为绝对定位的元素提供位置参考 */ /* 绝对定位 position: absolute 绝对定位的元素参考它最近的有定位的父级元素进行定位, 该定位可以是 sticky relative absolute fixed 若没有定位父级, 则参考窗口元素的位置进行定位 设置了绝对定位的元素会脱离正常的文档流, 元素原有位置将会被其他元素占据，可以使用绝对定位实现盒子堆叠效果 */ /* 固定定位 position: fixed; 设置了固定定位的元素, 它的位置参考浏览器窗口, 在页面内容滚动时, 它的位置不会改变。 设置了固定定位的元素会脱离文档流, 原有位置将会被其他元素占据。 */ /* 黏性定位 position: sticky 相对于父级进行固定定位, 当父级元素出现在窗口中并进行滚动时, 粘性定位的元素出现 fixed 定位效果 当父级元素离开窗口后, 粘性定位随父级元素离开窗口 注意父级元素不需要设置任何定位 */ .outer &#123; width: 800px; height: 2000px; background-color: #ccc; &#125; .inner &#123; width: 200px; height: 100px; background-color: skyblue; position: sticky; top: 100px; left: 0; &#125; .box &#123; width: 800px; height: 2000px; background-color: purple; &#125; &lt;/style&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!-- 问题：两个元素, 一个固定定位, 一个绝对定位, 它们两个都相对于窗口定位, 它们有什么区别。 --&gt; 11. 盒子水平垂直居中&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; /* 知道元素宽高的情况下 */ .box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; &#125; /* 不知道元素宽高的情况下 */ .box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; /* 知道元素宽高的情况下 */ .box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; &#125; &lt;style&gt; .wrap &#123; width: 100%; height: 500px; border: 2px solid skyblue; display: flex; justify-content: center; align-items: center; &#125; .box &#123; width: 100px; height: 100px; background: skyblue; &#125; &lt;/style&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .wrap &#123; width: 800px; height: 500px; border: 2px solid skyblue; display: table-cell; text-align: center; vertical-align: middle; &#125; .box &#123; width: 100px; height: 100px; display: inline-block; background: skyblue; &#125; &lt;/style&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; 12. 多行文本垂直居中&lt;style&gt; .wrap &#123; width: 100px; height: 500px; border: 2px solid skyblue; display: table; &#125; .box &#123; width: 100%; height: 100%; display: table-cell; vertical-align: middle; &#125; &lt;/style&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt; 多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本 &lt;/div&gt; &lt;/div&gt; 13. 行高如何继承&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; font-size: 20px; /* 直接被子元素继承, 即子元素的行高就是 20px */ /* line-height: 20px; */ /* 子元素继承该行高后, 会使用子元素字体大小乘以行高比例, 16 * 1.4 = 24 */ /* line-height: 1.5; */ /* 当行高值写成百分比以后, 会先使用当前字体大小乘以该百分比, 得到的值会被子元素继承, 20 * 2 = 40px */ line-height: 200%; &#125; .wrap &#123; font-size: 16px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt;这是一段文字&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 14. rem 单位rem 是 css 中的长度单位用于实现移动端适配。 移动端适配是指页面元素的宽、高都要随着设备的宽度进行等比缩放，即移动设备的宽度大，页面元素大，移动设备的宽度小，页面元素小。 rem 是一个相对单位，相对于根元素的字体大小进行计算。 比如根元素的字体大小是 20px，那么 1rem 就等于 20px，那么宽度 5rem 和高度 3rem 的盒子最终的宽高就为 100px，高度就为 60px。 html &#123; font-size: 20px; &#125; .box &#123; /* 100px */ width: 5rem; /* 60px */ height: 3rem; &#125; 要实现移动端适配效果，rem 单位需要和 css 中的媒体查询进行配合使用。 通过媒体查询检测设备的视口宽度，针对不同的设备视口宽度为根元素设置不同的字号大小。 如果设备视口宽度较大就为其设置较大的字号大小，如果设备的视口宽度较小就为其设置较小的字号大小。 @media (width: 375px) &#123; html &#123; font-size: 20px; &#125; &#125; @media (width: 414px) &#123; html &#123; font-size: 30px; &#125; &#125; 在真实的项目开发中针对不同的设备的视口宽度，根元素的字号大小要如何进行设置呢？ 在 rem 移动端适配方案中，我们通常将网页宽度等分为十份，然后将根元素的字号大小设置为视口宽度的十分之一，这样就将视口宽度和字号进行了关联。 @media (width: 320px) &#123; html &#123; font-size: 32px; &#125; &#125; @media (width: 375px) &#123; html &#123; font-size: 37.5px; &#125; &#125; @media (width: 414px) &#123; html &#123; font-size: 41.4px; &#125; &#125; 设计稿的宽度是 750px，设计稿中有一个盒子的宽高分别为 100px 和 50px，如何将它们转换为 rem 单位？ 我们可以将设计稿的宽度看成是某一个移动设备的视口宽度，那么在该视口宽度下根元素的字号大小为 75px。 我们只需要使用 100px 除以 75px ，50px 除以 75px，就可以得到盒子的对应的宽高 rem 值。 @media (width: 750px) &#123; html &#123; font-size: 75px; &#125; &#125; .box &#123; /* 盒子原本的像素值除以根元素字号大小: 100 / 75 = 1.333 50 / 75 = 0.666 */ width: 1.333rem; height: 0.666rem; background: skyblue; &#125; 通过 VSCode 编辑器中的 px to rem &amp; rpx &amp; vw (cssrem) 插件自动计算 rem 值。 先在 VSCode 编辑器中安装该插件，然后在 VSCode 编辑器的配置文件中设置参考的根元素字号大小 触发转换的快捷键默认为 Alt+Z &#123; &quot;cssrem.rootFontSize&quot;: 75 &#125; 改进媒体查询以适配所有移动端设备 @media (min-width: 320px) &#123; &#125; @media (min-width: 481px) &#123; &#125; @media (min-width: 641px) &#123; &#125; @media (min-width: 961px) &#123; &#125; @media (min-width: 1025px) &#123; &#125; @media (min-width: 1281px) &#123; &#125; 也可以通过 flexible.js 替换媒体查询，该 js 可以动态获取设备的视口宽度，为根元素动态设置十分之一的字号大小。 (function flexible(window, document) &#123; var docEl = document.documentElement; var dpr = window.devicePixelRatio || 1; // adjust body font size function setBodyFontSize() &#123; if (document.body) &#123; document.body.style.fontSize = 12 * dpr + &quot;px&quot;; &#125; else &#123; document.addEventListener(&quot;DOMContentLoaded&quot;, setBodyFontSize); &#125; &#125; setBodyFontSize(); // set 1rem = viewWidth / 10 function setRemUnit() &#123; var rem = docEl.clientWidth / 10; docEl.style.fontSize = rem + &quot;px&quot;; &#125; setRemUnit(); // reset rem unit on page resize window.addEventListener(&quot;resize&quot;, setRemUnit); window.addEventListener(&quot;pageshow&quot;, function (e) &#123; if (e.persisted) &#123; setRemUnit(); &#125; &#125;); // detect 0.5px supports if (dpr &gt;= 2) &#123; var fakeBody = document.createElement(&quot;body&quot;); var testElement = document.createElement(&quot;div&quot;); testElement.style.border = &quot;.5px solid transparent&quot;; fakeBody.appendChild(testElement); docEl.appendChild(fakeBody); if (testElement.offsetHeight === 1) &#123; docEl.classList.add(&quot;hairlines&quot;); &#125; docEl.removeChild(fakeBody); &#125; &#125;)(window, document); 15. 视口单位vw 和 vh 是 css 中的一个相对的长度单位，被称之为视口单位。 vw 就是 viewport width，表示它相对于视口的宽度进行计算。 vh 就是 viewport height，表示它相对于视口的高度进行计算。 1vw &#x3D; 1&#x2F;100 视口宽度，如果视口的宽度是 375px，那么 1vw &#x3D; 3.75px。 1vh &#x3D; 1&#x2F;100 视口高度，如果视口的高度是 667px，那么 1vh &#x3D; 6.76px。 .box &#123; /* 如果视口宽度是 375, 50 * 3.75 = 187.5 30 * 3.75 = 112.5 */ width: 50vw; height: 30vw; background: skyblue; &#125; .box &#123; /* 如果视口高度是 667, 50 * 6.67 = 333.5 30 * 6.67 = 200.1 */ width: 50vh; height: 30vh; background: skyblue; &#125; 设计稿的宽度是 750px，设计稿中有一个盒子的宽高分别为 100px 和 50px，如何将它们转换为 vw 单位？ 我们可以将设计稿的宽度看成是某一个移动设备的视口宽度，那么在该视口宽度下 1vw &#x3D; 7.5px。 我们只需要使用 100px 除以 7.5px ，50px 除以 7.5px，就可以得到盒子的对应的宽高 vw 值。 .box &#123; /* 设计稿宽度 750, 100 / 7.5 = 13.333vw 50 / 7.5 = 6.666vw */ width: 13.333vw; height: 6.666vw; background: skyblue; &#125; 注意一般在使用视口单位布局时，一个盒子的宽高一般不会混用 vw 和 vh，一般会基于 vw。 通过配置 cssrem 插件启用对 vw 的支持，使插件辅助我们计算最终的 vw 值。 &#123; &quot;cssrem.vw&quot;: true, &quot;cssrem.vwHover&quot;: true &#125;","categories":[],"tags":[]},{"title":"HTML高频面试题","slug":"HTML面试题","date":"2023-06-01T02:51:34.374Z","updated":"2023-06-01T02:53:37.169Z","comments":true,"path":"2023/06/01/HTML面试题/","link":"","permalink":"https://eathl.github.io/2023/06/01/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"01. HTML 语义化① 什么是 HTML 语义化 HTML 是一门标记语言，在这门语言中每一个标记都被赋予了特殊的含义。 开发者在构建页面布局时应使用恰当语义的 HTML 标签进行内容的展示。 &lt;!-- 用于定义标题 --&gt; &lt;h1&gt;&lt;/h1&gt; &lt;!-- 用于定义页面头部区域或 section 区域的页眉 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- 用于定义网页导航链接区域 --&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!-- 用于定义页面主体内容, 一个页面只能使用一次 --&gt; &lt;main&gt;&lt;/main&gt; &lt;!-- 用于定义一个页面中的一块自成一体的内容, 可以有自己的 header、footer、section 等 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 在 article 外, 主要用于定义页面侧边栏区域 --&gt; &lt;!-- 在 article 内, 主要用于定义主要内容的附属内容 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 表示有语义化的 div, 用于标记页面中的各个部分 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- 用于定义页面底部区域 --&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- 用于定义标题组 --&gt; &lt;hgroup&gt;&lt;/hgroup&gt; &lt;!-- 用于标记强调文本 --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;!-- 用于标记一个段落 --&gt; &lt;p&gt;&lt;/p&gt; &lt;!-- 用于标记一个独立的流内容, 比如图像、图标、代码等等 --&gt; &lt;figure&gt; &lt;img src=&quot;/media/cc0-images/elephant-660-480.jpg&quot; alt=&quot;Elephant at sunset&quot; /&gt; &lt;figcaption&gt;An elephant at sunset&lt;/figcaption&gt; &lt;/figure&gt; &lt;!-- 用于标记时间 --&gt; &lt;time&gt;2011-01-28&lt;/time&gt; ② HTML 语义化有什么好处 (1) 语义化的 HTML 代码使开发者更容易理解，增加了程序的可阅读性便于团队开发和维护 (2) 使搜索引擎能够快速定位网页中的重要内容，爬虫是依赖于标签来确定上下文和各个关键字的权重 (3) 在没有 CSS 样式情况下也能够让页面呈现出清晰的结构 (一些标记自带样式) (4) 极大程度利用标签的特点优化用户体验，比如 img 标记的 alt 属性和 title 属性、比如 label 标记 02. 块级元素与行内元素① 在 HTML 语言中哪些标记属于块级元素、哪些标记属于行内元素、哪些标记属于行内块元素 display 属性值为 block 或 table 的元素属于块级元素。 &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;ul&gt;&lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;table&gt;&lt;/table&gt; &lt;p&gt;&lt;/p&gt; display 属性值为 inline 的元素属于行内元素。 &lt;span&gt;&lt;/span&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt; &lt;i&gt;&lt;/i&gt; display 属性值为 inline-block 的元素属于行内块元素 &lt;img /&gt; &lt;input /&gt; &lt;button&gt;&lt;/button&gt; ② 块级元素有什么特点 (1) 块级元素独占一行 (2) 块级元素的宽度默认为 100% (3) 块级元素的高度、行高、外边距、内边距可控 (4) 可以包含行内元素可块级元素 ③ 行内元素有什么特点 (1) 行内元素可以与其他行内元素同在一行，在一行排不下的情况下才会换行显示 (2) 行内元素可设置水平方向上的内边距和外边距、垂直方向无效 (3) 行内元素不能设置宽度和高度，其宽度和高度由内容自动撑开 (4) 行内元素只能包含其他行内元素或文本 ④ 行内块元素有什么特点 (1) 和相邻的行内元素(行内块)在一行上但是中间会有空白的间隙 (2) 可设置宽度、但默认宽度为内容撑开的宽度 (3) 高度、内边距、外边距都可以设置 (4) 行内块元素不能转化为行内元素 ⑤ 通过哪些方式可以将行内元素转换为块级元素 display: block; /* 为行内元素设置 float:left/right 后, 该元素的 display 属性会被设置 block, 且拥有浮动特性。 */ float: left; float: right; /* 为行内元素设置决定定位或固定定位时, 会使得行内元素变为块级元素。 */ position: absolute; position: fixed; 03. src 属性与 href 属性的区别src 属性和 href 属性都可以用来引入外部的资源。 src 全称 source，通过 src 属性指向的内容会嵌入到文档中标签所在位置比如 js 脚本、img 图片。 当浏览器解析到该元素时，会暂停其它资源下载直到将该资源加载、编译、执行完毕。 正因为该特性所以我们才建议将 js 脚本放置在页面底部加载，防止阻塞页面加载影响用户体验。 href 全称 hyper reference 表示超文本引用，用于建立标签与外部资源的关系。 当浏览器解析到该元素时，会和其他资源并行下载，并不会停止对文档的解析，通常用于超链接和样式表的加载。 由于并行加载特性所以我们才建议将样式表文件防止在页面顶部加载，防止出现页面裸奔现象。 &lt;link href=&quot;cssfile.css&quot; /&gt; &lt;a href=&quot;http://www.webpage.com&quot;&gt;&lt;/a&gt; &lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt; &lt;img src=&quot;mypic.jpg&quot; /&gt; &lt;video src=&quot;&quot;&gt;&lt;/video&gt; &lt;audio src=&quot;&quot;&gt;&lt;/audio&gt; 04. 图像标记的 title 属性与 alt 属性alt 属性全称 alternate 表示备用，如果图像无法显示浏览器将渲染 alt 指定的内容。 title 属性表示图像的标题，当鼠标移动到图像上时显示 title 属性值中的内容。 &lt;img src=&quot;&quot; title=&quot;鼠标移入图像时展示的内容&quot; alt=&quot;图像无法显示时展示的内容&quot; /&gt; 05. label 标签的作用label 标签的作用是为使用鼠标的用户改进了可用性，当用户点击 label 标签中的文本时浏览器就会自动将焦点转到和该标签相关联的表单控件上。 &lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&gt; &lt;/form&gt; 06. GET 与 POST 的区别GET 和 POST，两者都是 HTTP 协议中发送请求的方法。 GET 一般用于从服务器端获取数据，POST 一般用于向服务器端传送数据。 GET 和 POST 本质上使用的都是 TCP 链接并无差别，但由于 HTTP 的规定和浏览器&#x2F;服务器的限制，导致他们在使用过程中会体现出一些区别。 ① GET 在浏览器回退时是无害的而 POST 会再次提交请求。 ② GET 产生的 URL 地址可以被存储为书签而 POST 不可以。 ③ GET 请求会被浏览器主动缓存而 POST 不会，除非手动设置。 ④ GET 请求只能进行 url 编码而 POST 支持多种编码方式。 ⑤ GET 请求参数会被完整保留在浏览器历史记录里而 POST 中的参数不会被保留。 ⑥ GET 请求在 URL 中传送的参数是有长度限制的而 POST 没有。 ⑦ GET 比 POST 更不安全，因为参数直接暴露在 URL 中，所以不能用来传递敏感信息。 ⑧ GET 参数通过 URL 传递，POST 放在请求体中。","categories":[],"tags":[]},{"title":"JavaScript面试题","slug":"JavaScript面试题","date":"2023-06-01T02:50:54.213Z","updated":"2023-06-01T02:51:13.755Z","comments":true,"path":"2023/06/01/JavaScript面试题/","link":"","permalink":"https://eathl.github.io/2023/06/01/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"01. 变量赋值JavaScript 中的基本数据类型包括字符串、数值、布尔值、undefined、Symbol。 JavaScript 中的引用数据类型包括对象、数组、函数、null。 let m = 100; let n = m; m = 200; console.log(n); // 100 基本数据类型在进行变量赋值时采用的是复制值的方式，n &#x3D; m 其实就是将 m 变量的值 100 复制了一份给了变量 n，重新为 m 变量赋值时变量 n 不会受到影响，所以变量 n 的值依然是 100。 let p1 = &#123; age: 20 &#125;; let p2 = p1; p2.age = 21; console.log(p1.age); //21 let m = 10; let n = 20; function display(m, n) &#123; //函数参数属于函数内部的局部变量 m = 100; n = 200; &#125; display(m, n); console.log(m); // 10 console.log(n); // 20 复杂数据类型在进行变量赋值时采用的是复制地址的方式，p2 &#x3D; p1 其实就是将变量 p1 对应的对象引用地址复制了一份给了变量 p2，此时 p1 变量和 p2 变量同时指向了同一个对象，所以无论是使用 p1 更改 age 还是使用 p2 更改 age，双方都会受到影响。 const o1 = &#123; x: 100, y: 200, &#125;; const o2 = o1; let x = o1.x; o2.x = 101; x = 102; console.log(o1.x); //101 let p = &#123; name: &quot;张三&quot; &#125;; function person(p) &#123; p.name = &quot;李四&quot;; //p是引用数据类型赋值 &#125; person(p); console.log(p.name); // 李四 在 JavaScript 中，var、let、const 有什么区别？ var、const、let 是 JavaScript 中用于声明变量的关键字，它们之间的主要区别在于作用域和是否可重新赋值。 var 声明的变量具有函数作用域（function scope），这意味着它们在整个函数体内都可见。 var 可以在任何时候重新赋值，也可以在声明之前使用（hoisted）。 function testVar() &#123; console.log(foo); // 输出 &quot;undefined&quot;，因为 var 变量会提升（hoisted） var foo = &quot;Hello&quot;; console.log(foo); // 输出 &quot;Hello&quot; foo = &quot;World&quot;; console.log(foo); // 输出 &quot;World&quot; &#125; testVar(); let 声明的变量具有块级作用域（block scope），这意味着它们只在定义它们的代码块内可见。 let 可以在任何时候重新赋值，但不能在声明之前使用(暂时性死区)。 function testLet() &#123; // console.log(bar); 在此时使用会报错，因为 let 变量不会提升 let bar = &quot;Hello&quot;; console.log(bar); // 输出 &quot;Hello&quot; bar = &quot;World&quot;; console.log(bar); // 输出 &quot;World&quot; &#123; let bar = &quot;Inside block&quot;; console.log(bar); // 输出 &quot;Inside block&quot;，因为这是一个新的作用域 &#125; console.log(bar); // 输出 &quot;World&quot; &#125; testLet(); const 用于声明一个常量，它具有与 let 相同的块级作用域，但在声明时必须初始化，且之后不能重新赋值。 function testConst() &#123; // console.log(baz); 在此时使用会报错，因为 const 变量不会提升 const baz = &quot;Hello&quot;; console.log(baz); // 输出 &quot;Hello&quot; // baz = &quot;World&quot;; // 如果尝试重新赋值，将会导致错误 &#123; const baz = &quot;Inside block&quot;; console.log(baz); // 输出 &quot;Inside block&quot;，因为这是一个新的作用域 &#125; console.log(baz); // 输出 &quot;Hello&quot; &#125; testConst(); 在现代 JavaScript 开发中，一般建议尽量使用 let 和 const，以避免因 var 变量提升和函数作用域可能导致的意外行为。 02. typeof 运算符typeof 运算符可以识别所有的基本数据类型、函数、可以识别是否是引用数据类型。 let str = &quot;Hello JavaScript&quot;; let m = 100; let isMarry = true; let unique = Symbol(&quot;unique&quot;); let n = undefined; function fn() &#123;&#125; let arr = [&quot;a&quot;, &quot;b&quot;]; let obj = &#123; name: &quot;张三&quot; &#125;; let empty = null; console.log(typeof str); // &quot;string&quot; console.log(typeof m); // &quot;number&quot; console.log(typeof isMarry); // &quot;boolean&quot; console.log(typeof unique); // &quot;symbol&quot; console.log(typeof n); // &quot;undefined&quot; console.log(typeof fn); // &quot;function&quot; console.log(typeof arr); // &quot;object&quot; console.log(typeof obj); // &quot;object&quot; console.log(typeof null); // &quot;object&quot; 03. 深拷贝深拷贝：拷贝数组、拷贝对象，逐层拷贝 浅拷贝：只拷贝一层 function deepClone(target) &#123; // 如果要拷贝的数据不是引用数据类型或要拷贝的数据为 null // 表示不需要深拷贝, 直接返回该数据即可 if (typeof target !== &quot;object&quot; || target === null) return target; // 创建新的变量用于保存拷贝结果 区分要拷贝的数据是数组还是对象 let result = target instanceof Array ? [] : &#123;&#125;; // 遍历要拷贝的数据 for (let key in target) &#123; // 拷贝时排除原型对象中的属性 if (target.hasOwnProperty(key)) &#123; // 递归拷贝 result[key] = deepClone(target[key]); &#125; &#125; // 返回拷贝结果 return result; &#125; let obj1 = &#123; a: 1, p: &#123; name: &quot;张三&quot;, &#125;, &#125;; let obj2 = deepClone(obj1); console.log(obj1 === obj2); console.log(obj2); obj2.p.name = &quot;李四&quot;; console.log(obj1.p.name); 编写一个方法用于比较两个对象是否深度相等。 在 JavaScript 中，可以使用递归方法来实现深度比较两个对象是否相等。 function isEqual(obj1, obj2) &#123; //如果两个对象引用地址相同意为这两个变量指向了同一个对象 不需要比较就是相等 if (obj1 === obj2) &#123; return true; &#125; //如果obj1和obj2是基本数据类型 不需要比较 直接返回false if ( typeof obj1 !== &quot;object&quot; || typeof obj2 !== &quot;object&quot; || obj1 === null || obj2 === null ) &#123; return false; &#125; //获取obj1对象的key 将key放置在数组中 const keys1 = Object.keys(obj1); //获取obj2对象的key 将key放置在数组中 const keys2 = Object.keys(obj2); //如果两个对象的属性数量不相同 那么肯定不相等 if (keys1.length !== keys2.length) &#123; return false; &#125; //遍历obj1对象对应的key值 for (const key of keys1) &#123; //判断当前遍历的obj1对象的key obj2是否拥有 if (!keys2.includes(key)) &#123; //返回false不相等 return false; &#125; //判断属性值是否相同 if (!isEqual(obj1[key], obj2[key])) &#123; return false; &#125; &#125; return true; &#125; 这个 isEqual 方法首先比较两个对象的引用是否相等，如果相等则返回 true。然后，检查两个参数是否都是对象类型，如果不是，则返回 false。接下来，比较两个对象的键的数量，如果不相等，则返回 false。最后，使用递归方法逐个比较键值，如果存在不相等的键值，则返回 false。如果所有键值都相等，则返回 true。 课上练习 function deepClone(target) &#123; // 如果要拷贝的数据不是引用数据类型或要拷贝的数据为 null // 表示不需要深拷贝, 直接返回该数据即可 if (typeof target !== &quot;object&quot; || target === null) return target; // 创建新的变量用于保存拷贝结果 区分要拷贝的数据是数组还是对象 let result = target instanceof Array ? [] : &#123;&#125;; // 遍历要拷贝的数据 for (let key in target) &#123; // 拷贝时排除原型对象中的属性 if (target.hasOwnProperty(key)) &#123; // 递归拷贝 result[key] = deepClone(target[key]); &#125; &#125; // 返回拷贝结果 return result; &#125; let obj = &#123; a:&#123; b:&#123; test:&quot;b&quot; &#125; &#125; &#125; --------------------------------------------------------- //深拷贝 let obj2 = deepClone(obj); console.log(obj===obj2); //false console.log(obj.a===obj2.a); //false console.log(obj.a.b===obj2.a.b); //false console.log(obj.a.b.test===obj2.a.b.test); //true ---------------------------------------------------------- //浅拷贝 let obj2 = &#123; ...obj, &#125; console.log(obj===obj2);//false console.log(obj.a===obj.a);//true 04. 数据类型转换规则① 其他类型的值转换为字符串 String(null); // &quot;null&quot; String(undefined); // &quot;undefined&quot; String(true); // &quot;true&quot; String(false); // &quot;false&quot; String(10); // &quot;10&quot; // 数组转为字符串是将数组中的所有元素按照 &quot;,&quot; 连接起来 // 相当于调用数组的 Array.prototype.join(&quot;,&quot;) 方法 // 如 [1, 2, 3] 转为 &quot;1,2,3&quot; // 空数组 [] 转为空字符串 // 数组中的 null 或 undefined, 会被当做空字符串处理 String([1, 2, 3]); // &quot;1,2,3&quot; String([]); // &quot;&quot; String([null]); // &quot;&quot; String([1, undefined, 3]); // &quot;1,,3&quot; // 普通对象转为字符串相当于直接使用 Object.prototype.toString() 方法 String(&#123;&#125;); // &quot;[object Object]&quot; ② 其他类型的值转换为数值 Number(null); // 0 Number(undefined); // NaN Number(&quot;10&quot;); // 10 Number(&quot;10px&quot;); // NaN Number(&quot;&quot;); // 0 Number(true); // 1 Number(false); // 0 // 数组会先被转换为原始类型, 然后再将转换后的原始类型转换为数值类型 Number([]); // 0 Number([&quot;10&quot;]); // 10 Number([&quot;10&quot;, &quot;20&quot;]); // NaN Number(&#123;&#125;); // NaN ③ 其他类型转换为布尔值 Boolean(null); // false Boolean(undefined); // false Boolean(&quot;&quot;); // false Boolean(NaN); // false Boolean(0); // false Boolean([]); // true Boolean(&#123;&#125;); // true Boolean(Infinity); // true ④ 对象、数组转换为原始类型 当对象类型需要被转为原始类型时，它会先调用对象的 valueOf 方法，如果 valueOf 方法返回原始类型的值，就使用这个值作为转换结果。 如果 valueOf 方法返回的不是原始类型的值，尝试调用对象的 toString 方法，使用该方法的返回值作为转换结果。 valueOf 方法用于返回对象的原始类型，一般由系统自动调用。 // 创建字符串对象 let strObject = new String(&quot;Hello&quot;); // 输出字符串对象 strObject; // String &#123; 0: &quot;H&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot; &#125; // 输出它字符串对象的类型 typeof strObject; // &quot;object&quot; // 获取字符串对象 strObject 的原始值 strObject.valueOf(); // &quot;Hello&quot; let object = &#123;&#125;; let array = []; object.valueOf(); // &#123;&#125; console.log(array.valueOf()); // [] let object = &#123;&#125;; let array = []; Object.prototype.valueOf = function () &#123; return 100; &#125;; console.log(object.valueOf()); // 100 console.log(array.valueOf()); // 100 // 将数组转换为数值类型 // 系统会先调用数组下的 valueOf 方法, 但是当前 valueOf 方法返回的就是数组, 所以系统去调用 toString 方法 // toString 方法调用之后返回了一个空字符串, 将空字符串转换为数值会得到 0 Number([]); // 在以下运算式中由于 + 号两边都不是数值, 所以要进行字符串连接操作 // 系统会先调用对象下的 valueOf 方法, 但是当前 valueOf 方法返回的就是对象, 所以系统去调用 toString 方法 // toString 方法调用后返回了 &#39;[object Object]&#39;, 所以最终连接的结果就是 &#39;[object Object][object Object]&#39; (&#123;&#125;) + &#123;&#125;; 课上练习 //valueOf:对象和数组都可以调用valueof方法 它用来返回对应的原始类型 const strObj = new String(&quot;Hello&quot;); console.log(strObj.valueOf()); 05. 宽松比较中的隐式转换在 JavaScript 中宽松比较会发生隐式类型转换，严格比较不会发生隐式类型转换。 ① 布尔类型和其他类型的相等比较 布尔类型的值在参数比较时值会被转换为数值类型，true 转换为 1，false 转换为 0 false == 0; // true true == 1; // true true == 2; // false const x = 10; if (x == true) &#123; console.log(x); // 不会被输出 undefined &#125; ② 数值类型和字符串类型的相等比较 当数值类型和字符串类型做相等比较时，字符串类型会被转换为数值类型。 如果字符串为数值字符串，则将其转换为对应的数值，如果是空字符串转换为 0，其他一律转换为 NaN。 NaN 和任何值比较都不相等，包括它自己。 0 == &quot;&quot;; // true 1 == &quot;1&quot;; // true true == &quot;1&quot;; // true false == &quot;0&quot;; // true false == &quot;&quot;; // true ③ 对象类型和原始类型的相等比较 当对象类型和原始类型做相等比较时，对象类型要被转换为原始类型。 &quot;[object Object]&quot; == &#123;&#125;; // true &quot;1,2,3&quot; == [1, 2, 3]; // true // 在以下比较中, 数组需要被转换为原始类型, 系统先调用 valueOf 方法, 但返回值不是原始值 // 系统继续调用 toString 方法, 得到 &quot;2&quot; // &quot;2&quot; == 2 比较, 字符串会被转换为数值 2, 所以 2 == 2 比较, 得到的结果是 true [2] == 2; [null] == 0 // true [undefined] == 0 // true [] == 0 // true // &quot;&quot; == false // &quot;&quot; == 0 // 0 == 0 [] == ![]; // true // &quot;[object Object]&quot; == false // &quot;[object Object]&quot; == 0 // NaN == 0 &#123;&#125; == !&#123;&#125; // false // 当两个操作数都是对象时，JavaScript 会比较其内存中的引用地址 [] == [] //false &#123;&#125; == &#123;&#125; //false ④ null、undefined 和其他类型的比较 null 和 undefined 宽松相等的结果为 true，null 和 null 相等，undefined 和 undefined 相等。 null 和 undefined 和其他值比较时都不相等。 null 和 undefined 都是假值。 null == undefined; // true null == false; // false undefined == false; // false 总结：在日常工作中进行相等比较时一律使用严格比较避免隐式类型转换产生的不可预知问题。 只有一种情况除外，当我们要判断对象中是否存在某一个属性时，可以使用宽松比较。 如果一个对象中的属性的值是 null 或是 undefined，我们都认为这个属性是不存在的。 const object = &#123; x: 100, &#125;; // 因为 x 无论是 null 还是 undefined, 和 null 进行比较时都会相等 if (object.x == null) &#123; console.log(&quot;不存在&quot;); &#125; else &#123; console.log(&quot;存在&quot;); &#125; 06. 运算中的隐式转换在使用 + - * &#x2F; 进行运算时，数据类型会发生隐式类型转换。 + 号两边只要有一个运算数是字符串类型，其他运算数都会被转换成字符串类型。 除了 + 号以外的其他运算符，比如 - * &#x2F; 等都会将运算数转换为数值类型。 + 作为正号使用会将运算数转换为数值类型。 &quot;11&quot; + 11; //&quot;1111&quot; &quot;11&quot; - 11; //0 11 + +&quot;11&quot;; //22 07. 原型对象基本使用在 JavaScript 中每一个构造函数都会配备一个名字叫做 prototype 的对象，我们称它为原型对象。 原型对象的作用是为了在实例对象之间进行属性共享。 // Person 构造函数 function Person() &#123;&#125; // Person 构造函数的原型对象 console.log(Person.prototype); // Person 构造函数 function Person(name) &#123; this.name = name; &#125; // 在 Person 构造函数的原型对象中添加 sayHello 方法 // 所有通过 Person 构造函数创建出来的实例对象都可以调用该方法 Person.prototype.sayHello = function () &#123; alert(`Hello, 我是$&#123;this.name&#125;`); &#125;; // 创建 p1 实例 const p1 = new Person(&quot;张三&quot;); // 创建 p2 实例 const p2 = new Person(&quot;李四&quot;); // 验证 p1 实例是否可以调用 sayHello 方法 p1.sayHello(); // 验证 p2 实例是否可以调用 sayHello 方法 p2.sayHello(); // 验证 p1 和 p2 调用的是否是同一个 sayHello 方法 alert(p1.sayHello === p2.sayHello); 实例对象在查找属性时，先在自身进行查找，自身如果找不到再去构造函数的原型对象中查找。 p1.sayHello = function () &#123; alert(`Hello, 我是$&#123;this.name&#125;, 我是实例对象自身身上的 sayHello 方法`); &#125;; p1.sayHello(); p2.sayHello(); 在实例对象身上有一个属性叫做 __proto__，它指向了实例的构造函数的原型对象，实例对象在查找属性时就是通过它找到的原型对象。 alert(p1.__proto__ === Person.prototype); __proto__ 被称之为隐式原型对象，实例会自动通过它去原型对象中查找，开发者不需要显式的去调用它。 alert(p2.sayHello === p2.__proto__.sayHello); 在每一个原型对象中都会有一个名字叫做 constructor 的属性，该属性指向了构造函数。 alert(Person.prototype.constructor === Person); alert(p1.constructor === Person); 08. 原型对象进阶Person.prototype 对象是 Object 构造函数的实例。 // 以下代码不需要开发者编写 Person.prototype = new Object(); // 此处 p1 调用的 hasOwnProperty 方法以及 toString 方法均来自 Object 构造函数的原型对象 alert(p1.hasOwnProperty(&quot;name&quot;)); alert(p1.toString()); function Person() &#123;&#125; let p1 = new Person(); p1.__proto__ === Person.prototype; // true Person.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; // true function Person() &#123;&#125; Person.__proto__ === Function.prototype; // true Function.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; // true 09. 继承function Person(name) &#123; this.name = name; &#125; function Student(name, number) &#123; this.number = number; &#125; const s1 = new Student(&quot;张三&quot;, 01); function Student(name, number) &#123; // 继承父类实例属性 Person.call(this, name); &#125; // 继承父类原型属性 Student.prototype.__proto__ = Person.prototype; const s1 = new Student(&quot;张三&quot;, 01); // ES6 语法糖 class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(`Hello, 我是$&#123;this.name&#125;`); &#125; &#125; class Student extends Person &#123; constructor(name, number) &#123; super(name); this.number = number; &#125; sayNumber() &#123; console.log(`我是$&#123;this.name&#125;, 我的学号是$&#123;this.number&#125;`); &#125; &#125; console.log(typeof Person); // &quot;function&quot; const tom = new Student(&quot;Tom&quot;, 1); tom.sayHello(); tom.sayNumber(); 课上练习 function Person(name) &#123; this.name = name; &#125; Person.prototype.eat = function () &#123; console.log(&quot;eat&quot;); &#125;; function Student(name, number) &#123; //继承父类实例属性 Person.call(this, name); this.number = number; &#125; Student.Prototype.__proto__ = Person.prototype; const s = new Student(&quot;沧九旻&quot;, 1); s.eat(); 10. instanceofinstanceof 运算符用于检查对象的类型，它返回一个布尔值，如果为真则表示该对象是特定类的实例，如果为假则不是。 tom instanceof Student; // true tom instanceof Person; // true tom instanceof Object; // true [] instanceof Array // true [] instanceof Object // true &#123;&#125; instanceof Object // true 11. 作用域作用域是指变量和函数的可访问范围。 JavaScript 中有全局作用域、局部作用域和块级作用域。 (1) 全局作用域 在全局作用域中声明的变量和函数可以在代码中的任何位置被访问。 // 全局作用域中声明变量 var globalVariable = &quot;global variable&quot;; // 全局作用域中声明函数 function globalFunction() &#123; console.log(&quot;global function&quot;); &#125; // 在函数中访问全局变量和函数 function myFunction() &#123; console.log(globalVariable); globalFunction(); &#125; // 输出：global variable 和 global function myFunction(); (2) 局部作用域 局部作用域是指在函数内部声明的变量和函数，只能在函数内部访问。 function myFunction() &#123; // 在函数内部声明局部变量 var localVariable = &quot;local variable&quot;; // 在函数内部声明局部函数 function localFunction() &#123; console.log(&quot;local function&quot;); &#125; console.log(localVariable); localFunction(); &#125; myFunction(); // 输出：local variable 和 local function console.log(localVariable); // 报错：localVariable is not defined (3) 块级作用域 块级作用域是指在 if、for、while 等语句中产生的作用域，在其中声明的变量和函数只在该代码块内部有效。 在 ES6 中使用关键字 let 和 const 声明的变量具有块级作用域。 // 使用 let 和 const 声明变量具有块级作用域 if (true) &#123; let x = 1; const y = 2; &#125; console.log(x); // 报错：x is not defined console.log(y); // 报错：y is not defined var a = 100; function print(fn) &#123; var a = 200; fn(); &#125; function fn() &#123; console.log(a); //100 &#125; //在函数内部查找变量和函数在哪调用没有关系，只和函数在哪定义有关系 print(fn); for (var i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); //4 输出3次 &#125;, 0); &#125; for (let i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); //1 2 3 &#125;, 0); &#125; console.log(a); //undefined var a = 12; function fn() &#123; console.log(a); //undefined var a = 13; &#125; fn(); console.log(a); //12 console.log(a); //undefined var a = 12; function fn() &#123; console.log(a); //12 a = 13; &#125; fn(); console.log(a); //13 console.log(a); //报错a is undefined 后面的代码不执行 a = 12; function fn() &#123; console.log(a); a = 13; &#125; fn(); console.log(a); var foo = 1; function bar() &#123; //在条件判断中声明的变量是参与预解析的 if (!foo) &#123; var foo = 10; &#125; console.log(foo); //10 &#125; bar(); var foo = 1; function bar() &#123; // 不管条件是否成立都会进行变量提升 var foo = undefined; // if (!undefined) =&gt; 将 undefined 转换为布尔值再取反 !false =&gt; true if (!foo) &#123; var foo = 10; &#125; console.log(foo); //10 &#125; bar(); var a = 10, b = 11, c = 13; function test(a) &#123; a = 1; var b = 2; c = 3; &#125; test(10); console.log(a); //10 console.log(b); //11 console.log(c); //3 if (!(&quot;a&quot; in window)) &#123; var a = 10; &#125; console.log(a); //undefined var a = 4; function b(x, y, a) &#123; console.log(a); //3 // 在 JS 非严格模式下实参集合与形参变量存在映射关系, 严格模式下该关系比切断了 arguments[2] = 10; console.log(a); //10 &#125; a = b(1, 2, 3); console.log(a); //undefined 没有返回值所以最终a的值为undefined var foo = &quot;hello&quot;; (function (foo) &#123; console.log(foo); //hello var foo = foo || &quot;world&quot;; console.log(foo); //hello &#125;)(foo); console.log(foo); //hello 12. 闭包闭包就是一个函数，一个引用了上级作用域链中的变量的函数，即使外部函数已不存在，也可以通过作用域链访问到外部函数中声明的变量。 function outer() &#123; var testVar = &quot;test&quot;; return function () &#123; console.log(testVar); //test &#125;; &#125; var inner = outer(); inner(); 使用闭包实现模块化开发 var module = (function () &#123; var privateVar = &quot;这个变量是私有的&quot;; function privateFunction() &#123; console.log(&quot;私有函数&quot;); &#125; return &#123; publicVar: &quot;这个变量是公开的&quot;, publicFunction: function () &#123; console.log(&quot;公开函数&quot;); &#125;, &#125;; &#125;)(); console.log(module.publicVar); module.publicFunction(); 使用闭包实现计数器功能 function counter() &#123; var count = 0; return function () &#123; count++; console.log(count); &#125;; &#125; var countFunc = counter(); countFunc(); // 1 countFunc(); // 2 使用闭包实现缓存功能 function cache() &#123; var results = &#123;&#125;; return function (key, val) &#123; if (results[key]) &#123; return results[key]; &#125; else &#123; results[key] = val; return val; &#125; &#125;; &#125; var getResults = cache(); console.log(getResults(&quot;a&quot;, 1)); // 1 console.log(getResults(&quot;a&quot;, 2)); // 1 console.log(getResults(&quot;b&quot;, 2)); // 2 使用闭包实现一次性函数 function singleUse() &#123; var isUsed = false; return function () &#123; if (!isUsed) &#123; console.log(&quot;执行一次&quot;); isUsed = true; &#125; else &#123; console.log(&quot;无法执行！&quot;); &#125; &#125;; &#125; var useFunc = singleUse(); useFunc(); // 执行一次 useFunc(); // 无法执行！ 面试题 var n = 0; function a() &#123; var n = 10; function b() &#123; n++; console.log(n); &#125; b(); return b; &#125; var c = a(); c(); console.log(n); 13. thisJavaScript 中的 this 是一个指向当前执行环境的关键字，用来访问当前执行环境的上下文。 this 具体指向的对象要取决于当前调用方式。 (1) 默认绑定：函数调用时没有明确指定 this 的指向，或者使用的是独立的函数调用方式时，this 会绑定到全局对象上。 function test() &#123; console.log(this); &#125; test(); // Window (浏览器) / global (Node.js) (2) 隐式绑定：函数作为对象的属性调用时，this 会绑定到该对象。 const obj = &#123; name: &quot;Alice&quot;, sayName() &#123; console.log(this.name); &#125;, &#125;; obj.sayName(); // Alice (3) 显式绑定：使用 apply、call、bind 等函数显式调用时，可以指定 this 的指向。 function greet() &#123; console.log(`Hello, $&#123;this.name&#125;!`); &#125; const person1 = &#123; name: &quot;Alice&quot; &#125;; const person2 = &#123; name: &quot;Bob&quot; &#125;; greet.call(person1); // Hello, Alice! greet.apply(person2); // Hello, Bob! const boundGreet = greet.bind(person1); // bind 方法返回一个新函数 boundGreet(); // Hello, Alice! (4) new 绑定：使用 new 关键字创建对象时，this 会绑定到新创建的对象上。 function Person(name) &#123; this.name = name; &#125; const person = new Person(&quot;Alice&quot;); console.log(person.name); // Alice (5) 箭头函数：箭头函数没有自己的 this 绑定，会继承上一层作用域中的 this。 const obj = &#123; name: &quot;Alice&quot;, logMyName: () =&gt; &#123; console.log(this.name); &#125;, &#125;; obj.logMyName(); // undefined 需要注意的是，箭头函数中的 this 不可以被显式地绑定或修改，因为箭头函数根本没有自己的 this。 14. 手写 bind 方法// 创建一个自定义的bind函数 Function.prototype.myBind = function (context) &#123; // 保存调用 myBind() 函数的函数对象 var fn = this; // 获取 myBind() 函数调用时传入的参数，不包括第一个参数（即需要绑定的 this 值或上下文对象） var args = Array.prototype.slice.call(arguments, 1); // 返回一个新函数 return function () &#123; // 获取新函数调用时的参数 var newArgs = Array.prototype.slice.call(arguments); // 将新函数的参数和调用myBind()函数时传入的参数合并 var allArgs = args.concat(newArgs); // 返回调用原函数时的结果 return fn.apply(context, allArgs); &#125;; &#125;; /* 上述代码首先在 Function.prototype 上添加了一个 myBind 方法，以实现自定义的 bind 方法。 当我们使用 myBind() 函数的时候，需要传入一个上下文对象（即需要绑定的 this 值）， 以及可以传入一系列参数，稍后会与新函数的参数合并。在myBind()函数中，先将调用myBind() 函数的原函数对象保存下来，并获取传入myBind()函数的参数数组，去除第一个参数（即上下文对象）。然后返回一个新函数， 新函数的作用是将调用新函数的参数与新函数之前已经传入myBind()函数中的参数合并起来，再通过 apply() 方法来调用原函数， 同时将上下文对象和所有参数传递给apply()方法，确保原函数能够正确的使用上下文和参数。 */ 15. 获取元素索引&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 获取 ul var ul = document.getElementById(&quot;ul&quot;); // 获取 ul 的所有子元素 var lis = ul.children; // 获取 ul 子元素的个数 var length = lis.length; // 遍历所有 li for (var i = 0; i &lt; length; i++) &#123; // 为 li 添加点击事件 lis[i].onclick = function () &#123; // 弹出 i 的值 alert(i); //3 &#125;; &#125; &lt;/script&gt; // 解决办法一: 使用 let 关键字声明变量 i, 使其产生块级作用域 for (let i = 0; i &lt; length; i++) &#123;&#125; // 解决办法二: 使用闭包使局部变量 i 不销毁 for (var i = 0; i &lt; length; i++) &#123; (function (i) &#123; // 为 li 添加点击事件 lis[i].onclick = function () &#123; // 弹出 i 的值 alert(i); //0 1 2 &#125;; &#125;)(i); &#125; 16. 同步和异步在 JavaScript 中，同步和异步是指代码的执行方式。 同步代码会按照代码的书写顺序一行一行地执行，每行代码必须等待前一行代码执行完成后才能执行。 在同步代码中如果某个操作需要执行的时间较长，代码的执行会被阻塞，直到操作完成才能继续执行下一行代码。 异步代码则是在某些代码执行完成前(ajax 请求、定时器等) ，允许继续执行其他的代码。 异步代码的执行结果不会立即得到，异步操作完成后再通过回调函数获取执行结果。 // 同步代码 console.log(&quot;Step 1&quot;); console.log(&quot;Step 2&quot;); console.log(&quot;Step 3&quot;); Step 1 Step 2 Step 3 // 异步代码 console.log(&quot;Step 1&quot;); setTimeout(function () &#123; console.log(&quot;Step 2&quot;); &#125;, 1000); console.log(&quot;Step 3&quot;); Step 1 Step 3 Step 2 JavaScript 是单线的，这意味着它只能在一个时间点执行一个任务，无法同时执行多个任务。 如果某一个任务的执行需要耗费比较长的时间，那么程序将会被卡住，所以异步应运而生。 console.log(1); setTimeout(() =&gt; &#123; console.log(2); &#125;, 1000); console.log(3); setTimeout(() =&gt; &#123; console.log(4); &#125;, 0); console.log(5); //1 3 5 4 2 17. JavaScript 运行原理(1) JavaScript 为单线程语言 JavaScript 是单线程语言，这意味着 JavaScript 在同一个时间点只能执行一项任务，该项任务未完成之前其他任务需要等待。 console.log(&quot;开始任务&quot;); // 同步任务 function sleep(ms) &#123; const start = new Date().getTime(); while (new Date().getTime() &lt; start + ms) &#123;&#125; &#125; sleep(2000); console.log(&quot;同步任务完成&quot;); console.log(&quot;结束任务&quot;); //开始任务 //阻塞2秒 继续向下执行 //同步任务完成 //结束任务 (2) JavaScript 是如何实现异步的? 既然 JavaScript 是单线程的，那么它是怎样实现非阻塞(异步)的呢? 上面我们所说的 JavaScript 指的是 EcmaScript，所有 EcmaScript 代码都在同一个线程中执行，这个单线程通常我们称它为主线程。 但是当 JavaScript 在浏览器中运行时，它不仅包含了 EcmaScript 还包含了浏览器提供的 web API，比如 window、document、setInterval、fetch 等，浏览器提供的 web API 不能在主线程中执行，浏览器提供了另外的线程供它们执行。 所以更加准确的说，JavaScript 本身可以只在一个线程中执行，但是运行在浏览器中的 JavaScript 由多个线程共同的执行。 console.log(&quot;Learning&quot;); console.log(&quot;About&quot;); console.log(&quot;The Event Loop&quot;); const recursion = () =&gt; &#123; recursion(); &#125;; recursion(); console.log(&quot;🐹&quot;); setTimeout(() =&gt; console.log(&quot;🐹🐹&quot;), 0); console.log(&quot;🐹🐹🐹&quot;); //1 3 2 // 如果调用堆栈为空并且任务队列中有待执行任务 // 依次将任务函数移动到调用堆栈中执行 if (callStack.isEmpty &amp;&amp; taskQueue.length) &#123; eventLoop(); &#125; (3) 宏任务(浏览器提供的)与微任务 宏任务包括 script（整体代码），setTimeout, setInterval, setImmediate, requestAnimationFrame 等。 微任务包括 Promise.then&#x2F;catch&#x2F;finally、process.nextTick (NodeJS)、MutationObserver 等。 微任务执行的优先级高于宏任务，因为微任务都是 ECMAScript，宏任务都是 WebAPI。 console.log(&quot;开始执行&quot;); setTimeout(() =&gt; &#123; console.log(&quot;setTimeout&quot;); &#125;, 0); Promise.resolve() .then(() =&gt; &#123; console.log(&quot;Promise 1&quot;); &#125;) .then(() =&gt; &#123; console.log(&quot;Promise 2&quot;); &#125;); console.log(&quot;结束执行&quot;); //开始执行 //结束执行 //Promise 1 //Promise 2 //setTimeout 18. PromiseJavaScript 的异步编程中最常见的问题之一就是回调地狱。 即一个异步操作完成后，需要执行另一个异步操作，而这个异步操作完成后又需要执行另一个异步操作，如此往复嵌套下去，代码变得十分冗长和难以维护。 getData(function (data1) &#123; getMoreData(data1, function (data2) &#123; getMoreData(data2, function (data3) &#123; getMoreData(data3, function (data4) &#123; // 继续嵌套下去... &#125;); &#125;); &#125;); &#125;); 为了避免回调地狱的问题，我们可以使用 Promise 来简化异步调用链。 getData() .then((data1) =&gt; getData(data1)) .then((data2) =&gt; getData(data2)) .then((data3) =&gt; getData(data3)) .then((data4) =&gt; getData(data4)) .catch((error) =&gt; &#123;&#125;); Promise 解决回调地狱问题，它是一种用于异步编程的语法结构，可以使异步操作变得更加简单、易读和可维护。 function getData(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onload = function () &#123; if (xhr.status === 200) &#123; resolve(xhr.response); &#125; else &#123; reject(Error(&quot;请求失败，错误码：&quot; + xhr.statusText)); &#125; &#125;; xhr.onerror = () =&gt; reject(Error(&quot;网络请求错误&quot;)); xhr.send(); &#125;); &#125; getData(&quot;https://jsonplaceholder.typicode.com/todos/1&quot;) .then((response) =&gt; console.log(&quot;成功获取数据：&quot;, response)) .catch((error) =&gt; console.error(&quot;获取数据失败：&quot;, error)); 封装 loadImage 方法使用 Promise 加载图片。 function loadImage(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image(); img.onload = () =&gt; resolve(img); img.onerror = (err) =&gt; reject(err); img.src = url; &#125;); &#125; // https://img95.699pic.com/photo/50046/5562.jpg_wh300.jpg // https://img95.699pic.com/photo/50136/1351.jpg_wh300.jpg // 使用方法 loadImage(&quot;https://img95.699pic.com/photo/50136/1351.jpg_wh300.jpg&quot;) .then((img) =&gt; &#123; // 加载成功 console.log(&quot;Image loaded&quot;); &#125;) .catch((err) =&gt; &#123; // 加载失败 console.error(err); &#125;); 题一：Promise 的基本用法是什么？如何使用 Promise 处理异步操作？ 答：Promise 是用于异步编程的一种解决方案，它可以更加优雅和可读地处理异步操作。Promise 有三种状态：Pending（等待态）、Resolved（成功态）和 Rejected（失败态）。在 Promise 构造函数中，可以传入一个 executor（执行器）函数，该函数接受两个参数，resolve 和 reject，代表 Promise 的成功和失败。在 executor 函数中，我们可以执行异步操作，并在操作成功或失败时调用相应的回调函数，例如： const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (Math.random() &gt; 0.5) &#123; resolve(&quot;success&quot;); &#125; else &#123; reject(&quot;failure&quot;); &#125; &#125;, 1000); &#125;); promise .then((result) =&gt; &#123; console.log(&quot;Promise resolved: &quot; + result); &#125;) .catch((error) =&gt; &#123; console.log(&quot;Promise rejected: &quot; + error); &#125;); 题二：如何使用 Promise.all 处理多个异步操作？ 答：Promise.all 方法接受一个 Promise 对象数组作为参数，将返回一个新的 Promise 对象。只有当数组中所有 Promise 对象都成功时，该 Promise 对象才会被 resolved；如果数组中任一个 Promise 对象失败，该 Promise 对象立即被 rejected，并返回失败的原因。 const promises = [ new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;a&quot;), 1000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;b&quot;), 2000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;c&quot;), 3000)), ]; Promise.all(promises) .then((results) =&gt; &#123; console.log(&quot;Promise.all resolved: &quot; + results); &#125;) .catch((error) =&gt; &#123; console.log(&quot;Promise.all rejected: &quot; + error); &#125;); 题三：如何使用 Promise.race 处理多个异步操作？ 答：Promise.race 方法接受一个 Promise 对象数组作为参数，将返回一个新的 Promise 对象。只要有一个 Promise 对象率先改变状态，该 Promise 对象就会采用第一个率先改变状态的 Promise 对象的状态。 const promises = [ new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;a&quot;), 1000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;b&quot;), 2000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;c&quot;), 3000)), ]; Promise.race(promises) .then((result) =&gt; &#123; console.log(&quot;Promise.race resolved: &quot; + result); &#125;) .catch((error) =&gt; &#123; console.log(&quot;Promise.race rejected: &quot; + error); &#125;); 题四：说出输出结果。 Promise.resolve() .then(() =&gt; &#123; console.log(1); &#125;) .catch(() =&gt; &#123; console.log(2); &#125;) .then(() =&gt; &#123; console.log(3); &#125;); //1 3 Promise.resolve() .then(() =&gt; &#123; console.log(1); throw new Error(); &#125;) .catch(() =&gt; &#123; console.log(2); &#125;) .then(() =&gt; &#123; console.log(3); &#125;); //1 2 3 Promise.resolve() .then(() =&gt; &#123; console.log(1); throw new Error(); &#125;) .catch(() =&gt; &#123; console.log(2); &#125;) .catch(() =&gt; &#123; console.log(3); &#125;); //1 2 //执行器立即执行 是同步任务 const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); console.log(2); &#125;); promise.then(() =&gt; &#123; console.log(3); &#125;); console.log(4); // 1 2 4 const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); console.log(2); resolve(); &#125;); promise.then(() =&gt; &#123; console.log(3); &#125;); console.log(4); // 1 2 4 3 const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve(&quot;success&quot;); //此处只是修改Promise状态而已 console.log(2); &#125;); promise.then(() =&gt; &#123; console.log(3); &#125;); console.log(4); //1 2 4 3 const promise1 = new Promise((resolve, reject) =&gt; &#123; console.log(0); resolve(3); &#125;); const promise2 = promise1.then((res) =&gt; &#123; console.log(res); //3 &#125;); console.log(1); console.log(2); //0 1 2 3 const fn = () =&gt; new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve(&quot;success&quot;); &#125;); fn().then((res) =&gt; &#123; console.log(res); &#125;); console.log(&quot;start&quot;); //1 start success console.log(&quot;start&quot;); setTimeout(() =&gt; &#123; console.log(&quot;time&quot;); &#125;); Promise.resolve().then(() =&gt; &#123; console.log(&quot;resolve&quot;); &#125;); console.log(&quot;end&quot;); //start end resolve time const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(&quot;timerStart&quot;); resolve(&quot;success&quot;); console.log(&quot;timerEnd&quot;); &#125;, 0); console.log(2); &#125;); promise.then((res) =&gt; &#123; console.log(res); &#125;); console.log(4); //1 2 4 timerStart timerEnd success setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); setTimeout(() =&gt; &#123; console.log(&quot;timer3&quot;); &#125;, 0); &#125;, 0); setTimeout(() =&gt; &#123; []; console.log(&quot;timer2&quot;); &#125;, 0); console.log(&quot;start&quot;); setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); Promise.resolve().then(() =&gt; &#123; console.log(&quot;promise&quot;); &#125;); &#125;, 0); setTimeout(() =&gt; &#123; console.log(&quot;timer2&quot;); &#125;, 0); console.log(&quot;start&quot;); Promise.resolve().then(() =&gt; &#123; console.log(&quot;promise1&quot;); const timer2 = setTimeout(() =&gt; &#123; console.log(&quot;timer2&quot;); &#125;, 0); &#125;); const timer1 = setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); Promise.resolve().then(() =&gt; &#123; console.log(&quot;promise2&quot;); &#125;); &#125;, 0); console.log(&quot;start&quot;); const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;success&quot;); &#125;, 1000); &#125;); const promise2 = promise1.then(() =&gt; &#123; throw new Error(&quot;error!!!&quot;); &#125;); console.log(&quot;promise1&quot;); console.log(&quot;promise2&quot;); setTimeout(() =&gt; &#123; console.log(&quot;promise1&quot;); console.log(&quot;promise2&quot;); &#125;, 2000); const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success1&quot;); reject(&quot;error&quot;); resolve(&quot;success2&quot;); &#125;); promise .then((res) =&gt; &#123; console.log(&quot;then: &quot;, res); &#125;) .catch((err) =&gt; &#123; console.log(&quot;catch: &quot;, err); &#125;); const promise = new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;); resolve(&quot;success2&quot;); &#125;); promise .then((res) =&gt; &#123; console.log(&quot;then1: &quot;, res); &#125;) .then((res) =&gt; &#123; console.log(&quot;then2: &quot;, res); &#125;) .catch((err) =&gt; &#123; console.log(&quot;catch: &quot;, err); &#125;) .then((res) =&gt; &#123; console.log(&quot;then3: &quot;, res); &#125;); // 透传 Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log); 19. async await(1) async&#x2F;await 概述 async&#x2F;await 是 ECMAScript 2017 中引入的新的异步编程特性。它是建立在 Promise 基础之上的，主要的不同是它提供了更为简单直接的语法机制来处理异步操作，并且可以让异步代码看起来像同步代码，这样可以提高代码的可读性和可维护性。 对于一个函数，只要在它的声明前面使用 async 关键字来修饰，那么它就可以使用 await 来等待异步操作的结果。以下是一个简单的例子： async function fetchRemoteData() &#123; const response = await fetch(&quot;https://api.example.com/data&quot;); const data = await response.json(); return data; &#125; 上述代码中，fetchRemoteData 函数声明了 async，这意味着它可以通过 await 等待异步函数 fetch 的返回值。fetchRemoteData 函数等待 fetch 函数的响应，然后再等待它的 JSON 内容，最后返回包含 JSON 消息的数据对象。 (2) async&#x2F;await 原理 async 函数是 Promise 对象的语法糖，async 函数本身返回的是一个 Promise 对象，因此可以与其他 Promise 对象进行链式调用。 async function asyncFunc1() &#123; return &quot;hello world&quot;; &#125; async function asyncFunc2() &#123; const result = await asyncFunc1(); return result.toUpperCase(); &#125; asyncFunc2().then((res) =&gt; &#123; console.log(res); // -&gt; &#39;HELLO WORLD&#39; &#125;); 在 async 函数中使用 await 表达式时，它的作用就是将异步调用的结果分割开来，使得后面的代码可以在异步调用返回结果之后继续执行。 async function demo () &#123; console.log(&#39;step 1&#39;) const result = await fetch(&#39;https://api.example.com/data&#39;) console.log(&#39;step 2&#39;) return result &#125; demo().then(...) 在以上例子中，当我们调用 demo() 函数时，第一行代码会打印一个“step 1”的消息，但注意此时代码并不会阻塞。随后，代码中的 await 表达式会发起一个异步调用，该调用需要一些时间来完成，我们称为“await point”。 (3) 异常处理 await 操作符也可以捕获异步操作产生的异常，就像 Promise.catch() 方法一样。因此，建议在 async 函数中使用 try-catch 块来处理可能出现的异常。以下是一个例子： async function divide (x, y) &#123; try &#123; const result = await Promise.resolve(x / y) return result &#125; catch (err) &#123; console.error(&#39;Error:&#39;, err) &#125; &#125; divide(10, 0).then(...) (4) 异步函数代码执行顺序说明 async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); //await关键字后面的代码可以将它看作是一个微任务 console.log(&quot;async1 end&quot;); &#125; async function async2() &#123; console.log(&quot;async2&quot;); &#125; async1(); console.log(&quot;start&quot;); //async1 start //async2 //start //async1 end function double(m) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(m * 2); &#125;, 1000); &#125;); &#125; const arr = [1, 2, 3]; (async function () &#123; for (var i = 0; i &lt; arr.length; i++) &#123; let r = await double(arr[i]); console.log(r); &#125; console.log(i); &#125;)(); console.log(&quot;start&quot;); //start //2 //4 //6 //3 20. 优化 DOM 操作性能(1) 优化操作 DOM 的频率 操作 DOM 的次数越少，页面反应就越快。 比如，我们使用一个 for 循环向一个 ul 列表里添加 1000 个 li 元素，这会导致 1000 次 DOM 操作，对页面性能的影响很大。 const list = document.querySelector(&quot;ul&quot;); for (let i = 0; i &lt; 1000; i++) &#123; const li = document.createElement(&quot;li&quot;); li.textContent = `Item $&#123;i&#125;`; list.appendChild(li); &#125; 可以使用 DocumentFragment 来高效地添加大量的 DOM 元素。 DocumentFragment 是一个虚拟的节点，可以将多个节点添加到 DocumentFragment 中，再将它一次性添加到 DOM 中，减少 DOM 操作的次数。 const list = document.querySelector(&quot;ul&quot;); const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; 1000; i++) &#123; const li = document.createElement(&quot;li&quot;); li.textContent = `Item $&#123;i&#125;`; fragment.appendChild(li); &#125; list.appendChild(fragment); (2) 缓存 DOM 元素的引用 每次获取 DOM 对象都会造成一定的性能浪费，所以我们可以使用变量来缓存 DOM 对象的引用。 // 未优化 document.querySelector(&quot;#myButton&quot;).addEventListener(&quot;click&quot;, function () &#123; document.querySelector(&quot;#myDiv&quot;).innerHTML = &quot;Button clicked&quot;; &#125;); // 优化后 const myButton = document.querySelector(&quot;#myButton&quot;); const myDiv = document.querySelector(&quot;#myDiv&quot;); myButton.addEventListener(&quot;click&quot;, function () &#123; myDiv.innerHTML = &quot;Button clicked&quot;; &#125;); (3) 使用事件委托 添加事件监听器也会影响性能，我们可以使用事件委托的方式来减少事件监听器的数量。 事件委托就是利用事件冒泡，将事件监听器添加到父元素上，然后根据事件冒泡的原理，在父元素上捕获事件，从而减少事件监听器的数量。 // 未优化 const listItems = document.querySelectorAll(&quot;li&quot;); for (let i = 0; i &lt; listItems.length; i++) &#123; listItems[i].addEventListener(&quot;click&quot;, function () &#123; console.log(`Item $&#123;i&#125; clicked`); &#125;); &#125; // 优化后 const list = document.querySelector(&quot;ul&quot;); list.addEventListener(&quot;click&quot;, function (e) &#123; if (e.target.tagName === &quot;LI&quot;) &#123; console.log(`Item $&#123;e.target.textContent&#125; clicked`); &#125; &#125;); (4) 使用 classList 代替 className className 常用于添加、删除、替换元素的 CSS 类，但是每次操作都会重新渲染元素，影响性能。 所以我们可以使用 classList 来代替 className 属性。 // 未优化 const myDiv = document.querySelector(&quot;#myDiv&quot;); myDiv.className = &quot;foo&quot;; // 优化后 const myDiv = document.querySelector(&quot;#myDiv&quot;); myDiv.classList.add(&quot;foo&quot;); (5) 避免多次修改样式 在 JavaScript 代码中频繁修改样式也会影响性能，我们可以将多个样式合并成一个字符串，然后一次性修改。 // 未优化 const myDiv = document.querySelector(&quot;#myDiv&quot;); myDiv.style.backgroundColor = &quot;red&quot;; myDiv.style.color = &quot;white&quot;; myDiv.style.fontSize = &quot;20px&quot;; // 优化后 const myDiv = document.querySelector(&quot;#myDiv&quot;); myDiv.style.cssText = &quot;background-color: red; color: white; font-size: 20px;&quot;; 21. property 与 attribute在 HTML 中，attribute 是指在 HTML 标签属性，property 是指 DOM 对象属性。 HTML 中的 attribute： &lt;div id=&quot;myDiv&quot; class=&quot;box&quot; data-value=&quot;123&quot;&gt;This is a box&lt;/div&gt; 可以使用 JavaScript 获取 attribute 的值： const myDiv = document.getElementById(&quot;myDiv&quot;); console.log(myDiv.getAttribute(&quot;data-value&quot;)); // &quot;123&quot; 也可以使用 JavaScript 动态设置 attribute 的值： myDiv.setAttribute(&quot;data-value&quot;, &quot;456&quot;); DOM 对象属性通过 DOM 对象点上属性的方式进行访问： const myDiv = document.getElementById(&quot;myDiv&quot;); console.log(myDiv.id); // &quot;myDiv&quot; console.log(myDiv.className); // &quot;box&quot; console.log(myDiv.innerHTML); // &quot;This is a box&quot; 也可以通过赋值语句来修改它们的值： myDiv.className = &quot;new-box&quot;; myDiv.innerHTML = &quot;This is a new box&quot;; HTML 标签属性和 DOM 对象属性都是为 HTML 元素提供附加信息的方式。它们之间有一定的联系，但在使用和目的方面有所不同。 HTML 标签属性： HTML 标签属性主要用于在 HTML 文档中为元素提附加信息。 例如，id 属性用于为一个 HTML 元素分配唯一的标识符，class 属性可以分配一个或多个类名，以便使用 CSS 进行样式设置。例如： &lt;input type=&quot;text&quot; id=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot; /&gt; DOM 对象属性： DOM 即文档对象模型（Document Object Model），是一个编程接口，允许我们使用 JavaScript 操作 HTML 文档的结构、样式和内容。 浏览器在读取 HTML 标签时，会生成标签对应的 DOM 对象，标准的 HTML 标签属性会成为 DOM 对象属性。 DOM 对象属性是我们在 JavaScript 中与 HTML 元素互动时所使用的属性，它不仅包括 HTML 属性，还包括其他与元素相关的属性。例如： const element = document.getElementById(&quot;username&quot;); console.log(element.tagName); // 输出元素的标签名称 element.disabled = true; // 将输入框设置为禁用状态 不同点： HTML 标签属性仅仅存在于 HTML 文档中，而 DOM 对象属性是我们 在 JavaScript 中使用的属性。 &lt;input checked /&gt; input.value=true; input.value=false; DOM 对象属性包含更多信息，除了标准的 HTML 标签属性以外还包括元素事件处理、元素宽高等。 有时，DOM 对象属性和 HTML 标签属性可能有区别。 checked 和 selected 在 HTML 中是布尔属性，但在 DOM 中是布尔值。 &lt;input checked value=&quot;默认值&quot; /&gt; input.value=&quot;值&quot; value 属性，HTML 标签的 value 属性始终存储的是设置属性时赋的默认值，而 DOM 对象中的 value 属性保存的是用户输入的内容。 class 属性用于在 HTML 标签中为元素设置类名，className 属性用于在 DOM 对象中设置元素类名。 一些 HTML 标签属性没有对应的 DOM 对象属性, 比如 aria-*, colspan 等 一些 DOM 对象属性没有对应的 HTML 标签属性, 比如 textContent 等 在实际项目中，你应该根据需要进行选择： 在 HTML 标签中，使用 HTML 属性定义元素的特征和基础数据。 在 JavaScript 代码中，通过操作 DOM 对象属性实现动态交互和修改元素状态。 代码示例： &lt;!-- 设置HTML标签属性 --&gt; &lt;button id=&quot;toggleBtn&quot; class=&quot;btn btn-primary&quot;&gt;切换禁用状态&lt;/button&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;script&gt; // JavaScript访问和操作DOM对象属性 const toggleBtn = document.getElementById(&quot;toggleBtn&quot;); const inputElement = document.getElementById(&quot;username&quot;); toggleBtn.addEventListener(&quot;click&quot;, () =&gt; &#123; inputElement.disabled = !inputElement.disabled; &#125;); &lt;/script&gt; 上面的代码中，我们在 HTML 中设置了基本的属性，然后在 JavaScript 中操作 DOM 对象属性实现点击按钮时切换输入框的禁用状态。 22. 通用的绑定事件的方法function addEvent(el, eventType, callback) &#123; if (el.addEventListener) &#123; el.addEventListener(eventType, callback, false); &#125; else if (el.attachEvent) &#123; el.attachEvent(&quot;on&quot; + eventType, callback); &#125; else &#123; el[&quot;on&quot; + eventType] = callback; &#125; &#125; el 是要绑定事件的元素，eventType 是要绑定的事件类型，callback 是事件处理程序。 这个方法支持现代浏览器、IE8+及更低版本的 IE 浏览器，以及不支持 addEventListener 的其他浏览器。 说出 onLoad (window) 事件与 DOMContentLoaded (document) 事件的区别？ onLoad (window) 页面结构加载完成再执行，DOMContentLoaded (document) 页面内容加载完成再执行。 23. 事件冒泡事件冒泡是指当一个元素上的事件被触发时，该事件会向父元素传递，如果父元素也绑定了该事件，则会接着触发父元素上的事件，以此类推直至到达最外层的祖先元素为止。 &lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;middle&quot;&gt; &lt;button id=&quot;inner&quot;&gt;Click me!&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; const outer = document.getElementById(&quot;outer&quot;); outer.addEventListener(&quot;click&quot;, function (event) &#123; console.log(&quot;Outer div clicked!&quot;); &#125;); const middle = document.getElementById(&quot;middle&quot;); middle.addEventListener(&quot;click&quot;, function (event) &#123; console.log(&quot;Middle div clicked!&quot;); &#125;); const inner = document.getElementById(&quot;inner&quot;); inner.addEventListener(&quot;click&quot;, function (event) &#123; //阻止事件冒泡 //event.stopPropergation(); console.log(&quot;Button clicked!&quot;); &#125;); 当点击按钮时，控制台会打印以下内容： Button clicked! Middle div clicked! Outer div clicked! 24. 事件委托事件委托是指将事件处理程序绑定在某一元素的祖先元素上，通过祖先元素处理该事件，这能够优化性能并减少事件处理程序的数量。 下面是一个示例，当单击一个 ul 元素的下拉菜单项时，会执行相应的操作： HTML 代码： &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;菜单项 1&lt;/li&gt; &lt;li&gt;菜单项 2&lt;/li&gt; &lt;li&gt;菜单项 3&lt;/li&gt; &lt;/ul&gt; JavaScript 代码： var menu = document.querySelector(&quot;.menu&quot;); menu.addEventListener(&quot;click&quot;, function (event) &#123; if (event.target.tagName === &quot;LI&quot;) &#123; console.log(&quot;你点击了菜单项：&quot;, event.target.textContent); &#125; &#125;); 25. Ajax在原生 JavaScript 中，我们可以使用 XMLHttpRequest 对象发送 Ajax 请求。 一、概述 Ajax 是 Asynchronous JavaScript and XML 的缩写，它是一种使用 JavaScript 在不刷新页面的情况下与服务器交换数据的技术。 二、创建 XMLHttpRequest 对象 要使用 XMLHttpRequest，首先需要创建一个 XMLHttpRequest 对象的实例。 var xhr = new XMLHttpRequest(); 三、设置请求 当实例创建完毕后，可以使用 XMLHttpRequest 对象的 open() 方法来设置请求，open() 方法接受三个参数： 请求的类型（GET 或 POST） 请求的 URL 请求是否异步（true 表示异步，false 表示同步） xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data&quot;, true); 四、发送请求 设置好请求之后，可以使用 XMLHttpRequest 对象的 send() 方法来发送请求。 如果是 GET 请求，send() 方法不需要参数； 如果是 POST 请求，send() 方法需要传递一个字符串或 FormData 对象。 xhr.send(); 五、处理响应 要处理服务器返回的响应，可以使用 XMLHttpRequest 对象的 onreadystatechange 事件处理程序。 当请求的状态（readyState）发生变化时，onreadystatechange 事件处理程序将被触发。 readyState 的可能值包括： 0：请求未初始化（已创建 XMLHttpRequest 实例，但尚未调用 open() 方法） 1：请求已经设置（已调用 open() 方法，但尚未调用 send() 方法） 2：请求已发送（已调用 send() 方法，但尚未收到响应） 3：请求处理中（已收到部分响应数据） 4：请求已完成（已收到所有的响应数据） 当 readyState 等于 4 且 HTTP 状态码为 200 时，表示请求成功，此时可以获取并处理服务器返回的数据。 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.responseText)); &#125; &#125;; xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data&quot;, true); xhr.send(); 实际项目中的代码示例： 获取 GitHub 用户信息： var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var user = JSON.parse(xhr.responseText); console.log(&quot;GitHub 用户名：&quot; + user.login); &#125; &#125;; xhr.open(&quot;GET&quot;, &quot;https://api.github.com/users/octocat&quot;, true); xhr.send(); 从 API 中获取一条随机笑话： var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var joke = JSON.parse(xhr.responseText); console.log(&quot;随机笑话：&quot; + joke.value.joke); &#125; &#125;; xhr.open(&quot;GET&quot;, &quot;https://api.icndb.com/jokes/random&quot;, true); xhr.send(); 26. 跨域只允许同源访问，协议、域名、端口这三者任何一样不相同，都需要跨域 (1) 跨域概述 跨域是指跨越原始访问控制(domains)的访问。 在 Web 应用中，浏览器出于安全考虑一般情况下是只允许同源请求。 所谓同源就是协议、域名以及端口号相同，如果请求的资源来自于不同的源（域名、端口、协议），则会出现跨域。 这种安全策略被称为 “同源策略”，同源策略的主要目的是为了保证用户信息的安全，阻止恶意攻击。 如果没有同源策略，攻击者可以通过编写脚本，从一个网站发送请求绕过用户认证，获取用户的隐私数据。 (2) 如何解决跨域问题 ① JSONP JSONP (JSON with Padding) 是一种通过 script 标签跨域访问数据的方式，因为 script 标签本身就允许跨域。 // 客户端 function jsonp(url, callbackName) &#123; const script = document.createElement(&quot;script&quot;); script.src = `$&#123;url&#125;?callback=$&#123;callbackName&#125;`; document.body.appendChild(script); &#125; function handleData(data) &#123; console.log(data); &#125; jsonp(&quot;https://example.com/jsonp&quot;, &quot;handleData&quot;); // 服务端 const http = require(&quot;http&quot;); const url = require(&quot;url&quot;); http .createServer(function (req, res) &#123; const query = url.parse(req.url, true).query; const callback = query.callback; const data = &#123; name: &quot;Jack&quot;, age: 20, &#125;; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;application/javascript&quot; &#125;); res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`); &#125;) .listen(3000); 需要注意的是，JSONP 总是发起一个 GET 请求，所以仅仅适用于请求数据，而不能发送数据。 ② CORS (跨域资源共享) CORS 是一种更为现代化的跨域方案，它允许浏览器与服务器之间进行跨域通信。 服务端需要在响应头中添加 CORS 相关配置，例如 Access-Control-Allow-Origin，这样客户端就可以跨域访问该资源。 // 客户端 const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;https://example.com/api/data&quot;); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.responseText)); &#125; &#125;; xhr.send(); // 服务端 const http = require(&quot;http&quot;); http .createServer(function (req, res) &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, // &quot;*&quot; 表示允许任何域名跨域访问，也可以设置指定域名 &#125;); const data = &#123; name: &quot;Lily&quot;, age: 22, &#125;; res.end(JSON.stringify(data)); &#125;) .listen(3000); 除了以上两种方法，还有其他一些常用的跨域解决方案，如使用代理服务器、postMessage 通信等。 27. 本地存储cookie 是浏览器保存用户数据的一种方式。 localStorage 和 sessionStorage 是 HTML5 引入的 Web Storage，同样是用于在浏览器中保存数据。 // 设置cookie document.cookie = &quot;name=John Doe; expires=Thu, 18 Dec 2022 12:00:00 UTC; path=/&quot;; // 获取cookie let name = document.cookie; console.log(name); // 存储数据 localStorage.setItem(&quot;name&quot;, &quot;John Doe&quot;); localStorage.setItem(&quot;age&quot;, &quot;30&quot;); // 获取数据 let name = localStorage.getItem(&quot;name&quot;); let age = localStorage.getItem(&quot;age&quot;); console.log(name, age); // 存储数据 sessionStorage.setItem(&quot;name&quot;, &quot;John Doe&quot;); sessionStorage.setItem(&quot;age&quot;, &quot;30&quot;); // 获取数据 let name = sessionStorage.getItem(&quot;name&quot;); let age = sessionStorage.getItem(&quot;age&quot;); console.log(name, age); cookie 保存数据的容量较小，只有 4KB 左右，而 localStorage 和 sessionStorage 可以存储更多数据。 cookie 可以设置过期时间，不过需要手动管理，而 localStorage 和 sessionStorage 可以无限期保存数据。 cookie 可以跨域传递数据，而 localStorage 和 sessionStorage 只能在同源页面之间共享数据。 cookie 保存在浏览器的 cookie 文件夹中，localStorage 和 sessionStorage 保存在浏览器中的特定位置，更安全。 如果需要跨页面或跨域传递数据，或者需要在用户不主动清除浏览器缓存的情况下保存数据，建议使用 cookie。 如果需要在同源页面中保存少量数据，建议使用 localStorage。 如果需要在同源页面中保存临时数据，建议使用 sessionStorage。 28. HTTP 协议(1) HTTP 协议概述 HTTP (Hypertext Transfer Protocol) 是一种在 Web 应用中进行数据通信的协议。 在客户端和服务器之间交换的所有数据（例如 HTML 文件、图像文件、查询结果等）都必须遵循 HTTP 协议中规定的格式。 HTTP 协议基于客户端服务器模型，客户端发送请求，服务器发送响应。 通常，Web 浏览器是作为客户端出现的。当您在浏览器中输入一个 URL 时，这实际上向服务器发出了一个请求，以获取网页。 服务器将响应包含在一个 HTTP 格式的消息中，并将其发送回给浏览器。浏览器将消息解析并显示响应的文本、图像等内容。 HTTP 格式的消息分为两类：请求和响应。 (2) HTTP 请求 HTTP 请求由三个部分组成： 请求方法：指定对服务器执行的操作类型。常用方法包括 GET、POST、PUT、DELETE 等。 请求 URI：指定要操作的资源的 URI。 HTTP 版本：该消息所使用的 HTTP 版本。 例如，以下是一个 HTTP GET 请求的示例： GET /index.html HTTP/1.1 Host: www.example.com 这个请求由 GET 方法（请求获取资源）组成，请求的 URI 是 /index.html，HTTP 版本是 1.1。 请求消息可以包含其他信息，如下所示： GET /search?q=example HTTP/1.1 Host: www.google.com Accept-Encoding: gzip, deflate, br User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3 其中，Accept-Encoding 和 User-Agent 是请求首部。 (3) HTTP 响应 HTTP 响应也由三个部分组成： 状态码：指定执行该请求后服务器的状态。常见的状态码包括 200 OK（请求成功）、404 Not Found（未找到请求的资源）等。 响应首部：包含与响应相关的元数据，如服务器类型、响应时间等。 实体：包含响应的实际内容，例如网页、图像等。 以下是一个 HTTP 响应的示例： HTTP/1.1 200 OK Content-Type: text/html; charset=UTF-8 Content-Length: 138 Date: Tue, 06 Jun 2017 09:45:32 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to Example.com&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 状态码为 200（请求成功），并且响应实体中包含一个 HTML 页面。 (4) HTTP 方法 HTTP 协议支持多种请求方法。以下是一些常见的方法： GET：请求获取资源。应该只用于获取数据，不应更改数据。 POST：请求向服务器提交数据。该请求可能导致服务器更改状态或执行其他操作。 PUT：请求更新服务器上的资源。 DELETE：请求删除服务器上的资源。 (5) HTTP 状态码 HTTP 响应状态码指示 HTTP 请求是否已成功完成。以下是一些常见的状态码及其含义： 200 OK：请求已成功完成。 201 Created：服务器已成功创建新资源。 302 重定向 400 Bad Request：请求无效，例如缺少一些必需的参数。 401 Unauthorized：未授权，需要身份验证。 404 Not Found：请求的资源不存在。 500 Internal Server Error：服务器遇到了错误，无法完成请求。 29. restful APIRESTful（Representational State Transfer）是一种软件架构风格，主要用于网络上的 web 服务。 RESTful API 按照资源进行设计，使用标准的 HTTP 方法，如 GET、POST、PUT 和 DELETE，实现资源的创建、读取、更新和删除操作（CRUD 操作）。 资源：RESTful API 中的资源可以是一篇文章、用户信息或者商品等，这些资源可以通过 URI（统一资源标识符）进行标识，例如：&#x2F;users、&#x2F;articles 等。 方法：RESTful API 中的方法是 HTTP 请求动词，例如：GET、POST、PUT、DELETE 等。不同的动词表示对资源的不同操作。 状态：资源的状态表示请求操作的结果，使用 HTTP 状态码来传达，如 200 表示操作成功，404 表示资源未找到，500 表示服务器内部错误等。 以下是一个使用 Node.js 的 Express 框架创建的简单 RESTful 风格的 API 的代码示例。 // 导入模块 const express = require(&quot;express&quot;); const app = express(); // 使用中间件 app.use(express.json()); // 资源：用户 const users = []; // 方法： // 1. 获取所有用户：GET /users app.get(&quot;/users&quot;, (req, res) =&gt; &#123; res.status(200).json(users); &#125;); // 2. 创建用户：POST /users app.post(&quot;/users&quot;, (req, res) =&gt; &#123; const newUser = &#123; id: users.length + 1, name: req.body.name, age: req.body.age, &#125;; users.push(newUser); res.status(201).json(newUser); &#125;); // 3. 获取单个用户：GET /users/:id app.get(&quot;/users/:id&quot;, (req, res) =&gt; &#123; const user = users.find((u) =&gt; u.id === parseInt(req.params.id)); if (!user) res.status(404).send(&quot;用户未找到。&quot;); res.status(200).json(user); &#125;); // 4. 修改用户信息：PUT /users/:id app.put(&quot;/users/:id&quot;, (req, res) =&gt; &#123; const user = users.find((u) =&gt; u.id === parseInt(req.params.id)); if (!user) res.status(404).send(&quot;用户未找到。&quot;); user.name = req.body.name; user.age = req.body.age; res.status(200).json(user); &#125;); // 5. 删除用户：DELETE /users/:id app.delete(&quot;/users/:id&quot;, (req, res) =&gt; &#123; const user = users.find((u) =&gt; u.id === parseInt(req.params.id)); if (!user) res.status(404).send(&quot;用户未找到。&quot;); const index = users.indexOf(user); users.splice(index, 1); res.status(204).send(); &#125;); const port = process.env.PORT || 3000; app.listen(port, () =&gt; console.log(`Listening on port $&#123;port&#125;...`)); 30. 数组 splice、slice在 JavaScript 中，数组的 splice 和 slice 是两个用于操作数组的方法，它们的用法和区别如下： splice 方法用于在数组内插入、删除或替换元素。语法如下： array.splice(startIndex, deleteCount, item1, ..., itemN) startIndex：开始变更的索引（包括该位置的元素） deleteCount：要删除的元素个数，可选。如果省略该参数，那么 startIndex 之后的所有元素都会被删除。 item1, …, itemN：要插入到数组中的元素，可选。 splice 方法的返回值是一个包含被删除元素的数组。如果没有元素被删除，则返回一个空数组。 const arr = [1, 2, 3, 4, 5]; const removed = arr.splice(1, 2, 7, 8); console.log(arr); // [1, 7, 8, 4, 5] console.log(removed); // [2, 3] slice 方法用于截取数组的子数组。它不会修改原数组，而是返回一个新的数组。 array.slice(startIndex, endIndex); startIndex：起始索引（包含），可选。默认值为 0。 endIndex：结束索引（不包含），可选。默认值为数组的长度。 const arr = [1, 2, 3, 4, 5]; const newArr = arr.slice(1, 4); console.log(arr); // [1, 2, 3, 4, 5] （原数组不变） console.log(newArr); // [2, 3, 4] splice 和 slice 区别： splice 方法会修改原数组，而 slice 方法不会修改原数组，而是返回一个新数组。 splice 方法可以插入、删除、替换元素，而 slice 方法用于截取子数组。 endIndex 参数在 slice 中是不包含在返回数组中的，而 splice 的 deleteCount 则是包含在被删除的元素个数中。 31. map 与 parseInt请说出下列代码的返回值是什么 [10, 20, 30].map(parseInt); //[10,NaN,NaN] arr.map((item, index, arr) =&gt; &#123;&#125;); parseInt(10, 0); //10 parseInt(20, 1); //NaN parseInt(30, 2); //NaN 以上代码是想将数组 [10, 20, 30] 中的每个元素用 parseInt 函数解析成整数，然而实际执行结果却与预期不符：执行后的结果是 [10, NaN, NaN]。 为了理解这个现象，我们需要深入了解 map 和 parseInt 函数的工作原理。 map 是数组的一个方法，它接收一个函数作为参数。map 会遍历数组的每一个元素，并对每个元素执行传入的函数。 传入的函数有三个参数：当前元素、当前元素的索引和整个数组。 map 函数返回一个新的数组，这个新数组中的元素是原数组每个元素经过传入函数处理后的结果。 parseInt 是一个全局函数，用于将字符串转换为整数。 它接受两个参数：要解析的字符串和一个可选的基数（例如 2 表示二进制，10 表示十进制等）。 当提供基数时，parseInt 会按照给定的进制把字符串转换为对应的整数。 当我们将 parseInt 传入 map 函数时，map 函数会依次为数组中每个元素调用 parseInt 函数，并把当前元素值、索引和整个数组分别传给 parseInt 的第一个、第二个和第三个参数。然而此时 parseInt 函数的第二个参数并非作为解析的基数，而是把数组索引作为基数了。这就导致了实际执行结果与预期不符。 当处理第一个元素（10）时，parseInt 接收到的参数是 parseInt(10, 0)（0 是数组索引）。基数为 0 时，parseInt 会默认按照十进制进行解析，因此结果是 10。 当处理第二个元素（20）时，parseInt 接收到的参数是 parseInt(20, 1)（1 是数组索引）。此时基数为 1，但 1 是一个无效的基数，因此 parseInt 函数会返回 NaN。 当处理第三个元素（30）时，parseInt 接收到的参数是 parseInt(30, 2)（2 是数组索引）。此时基数为 2，即二进制，而 30 并不符合二进制表示，所以 parseInt 返回 NaN。 因此，[10, 20, 30].map(parseInt) 的执行结果是 [10, NaN, NaN]。 如果你想用 map 函数将 [10, 20, 30] 中的每个元素转换为整数，可以这样做： [10, 20, 30].map((num) =&gt; parseInt(num)); 这样就可以得到预期的结果 [10, 20, 30]。 32. 函数声明与函数表达式函数声明（Function Declaration）和函数表达式（Function Expression）都是在 JavaScript 中定义和创建函数的两种方法。 1. 函数声明（Function Declaration） 函数声明是使用 function 关键字后跟函数名称和函数体来定义函数的方法。函数声明会在代码执行前被初始化，因此可以在声明之前调用。这种行为被称为函数提升（hoisting）。 // 函数声明 function greeting(name) &#123; return &quot;Hello, &quot; + name; &#125; // 调用函数 console.log(greeting(&quot;John&quot;)); 2. 函数表达式（Function Expression） 函数表达式是将一个函数赋值给一个变量。函数表达式在执行到其所在行时，通过变量名进行调用。 // 函数表达式 const greeting = function (name) &#123; return &quot;Hello, &quot; + name; &#125;; // 调用函数 console.log(greeting(&quot;John&quot;)); 函数声明与函数表达式的区别： 提升：函数声明在执行前会被提升，这意味着你可以在声明之前调用它。而函数表达式需要等到其所在行被执行后，才可被调用。 语法：函数声明需要提供一个函数名，而函数表达式可以是命名的也可以是匿名的。 // 函数声明提升示例 console.log(square(5)); // 输出：25 function square(num) &#123; return num * num; &#125; // 函数表达式提升示例 console.log(square(5)); // 会抛出 TypeError: square is not a function const square = function (num) &#123; return num * num; &#125;; 33. 手写 trim 方法在 JavaScript 中，字符串对象自带了 trim() 方法，可以用来去除字符串两端的空格。 但是如果需要自己手动实现一个 trim() 方法，可以使用正则表达式来去除字符串两端的空格。 String.prototype.trim = function () &#123; return this.replace(/^\\s+|\\s+$/g, &quot;&quot;); &#125;; // 使用自定义的 trim() 方法 let str = &quot; Hello, World! &quot;; console.log(str.trim()); // 输出：&#39;Hello, World!&#39; 我们扩展了 String.prototype 对象，添加了一个名为 trim() 的方法。该方法使用正则表达式来去除字符串两端的空格，并返回处理后的字符串。 正则表达式 /^\\s+|\\s+$/g 匹配字符串两端的空格。其中： ^ 表示匹配字符串开头； \\s+ 表示匹配一个或多个空格； | 表示或者； $ 表示匹配字符串结尾； g 表示全局匹配。 因此，/^\\s+|\\s+$/g 可以匹配字符串开头和结尾的空格，并将其替换为空字符串。 34. 手写 max 方法 目标：编写 myMax 方法模拟 Math.max 方法的功能 可以使用 apply() 方法来模拟 Math.max 方法的功能。 apply() 方法可以接受一个数组作为参数，并将其展开为一系列参数，传递给函数。 function myMax() &#123; let max = arguments[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; max) &#123; max = arguments[i]; &#125; &#125; return max; &#125; let nums = [1, 5, 3, 9, 2]; let maxNum = myMax.apply(null, nums); console.log(maxNum); // 输出：9 35. 捕获异常在 JavaScript 中，可以使用 try-catch 语句来捕获异常。 try-catch 语句包含两个关键字：try 和 catch。try 代码块中包含可能会引发异常的代码，而 catch 代码块用于处理异常情况。 try &#123; // 可能会引发异常的代码 let x = y + 1; &#125; catch (e) &#123; // 处理异常情况 console.log(&quot;发生了异常：&quot; + e.message); &#125; onerror 事件：用于捕获全局范围内发生的异常。可以使用 window.onerror 事件来捕获全局范围内的异常。例如： // 该事件会在发生异常时自动触发，并将异常信息作为参数传递给事件处理函数。 window.onerror = function (message, url, line, column, error) &#123; console.log(&quot;发生了异常：&quot; + message); &#125;; 36. JSON 介绍JSON 是一种轻量级的数据交换格式，它的全称是 JavaScript Object Notation。 JSON 最初是由 Douglas Crockford 在 2001 年提出的，它是一种基于文本的数据格式，具有易于阅读和编写的特点。 JSON 格式通常用于通过网络传输数据，因为它可以被多种编程语言解析和生成。 JSON 与 JavaScript 密切相关，因为 JSON 的语法是 JavaScript 对象的子集。 这意味着在 JavaScrip t 中，我们可以轻松地将 JSON 格式的数据转换为 JavaScript 对象，反之亦然。 JavaScript 提供了两个内置方法来解析和生成 JSON 数据：JSON.parse() 和 JSON.stringify()。 序列化：将对象转换为 JSON 字符串 反序列化：将 JSON 字符串转换为 JSON 对象。 37. 获取查询参数编写一个方法用于获取 url 中的查询参数并返回其对象格式。 function getQueryParams() &#123; var queryParams = &#123;&#125;; var queryString = window.location.search.substring(1); var pairs = queryString.split(&quot;&amp;&quot;); for (var i = 0; i &lt; pairs.length; i++) &#123; var pair = pairs[i].split(&quot;=&quot;); var key = decodeURIComponent(pair[0]); var value = decodeURIComponent(pair[1]); if (typeof queryParams[key] === &quot;undefined&quot;) &#123; queryParams[key] = value; &#125; else if (Array.isArray(queryParams[key])) &#123; queryParams[key].push(value); &#125; else &#123; queryParams[key] = [queryParams[key], value]; &#125; &#125; return queryParams; &#125; 当用户需要从 URL 中获取查询参数时，可以使用以下 JavaScript 函数来实现： function getUrlParams(url) &#123; const params = &#123;&#125;; const regex = /([^&amp;?+]+)=([^&amp;?+]+)/g; url.replace(regex, function () &#123; params[arguments[1]] = arguments[2]; &#125;); return params; &#125; 这个函数使用正则表达式来匹配 URL 中的查询参数，然后将它们存储在一个对象中并返回。 https://example.com/search?q=javascript&amp;lang=en&amp;page=2 我们可以调用 getUrlParams 函数来获取查询参数： const urlParams = getUrlParams( &quot;https://example.com/search?q=javascript&amp;lang=en&amp;page=2&quot; ); console.log(urlParams); 这将输出以下内容： &#123; q: &quot;javascript&quot;, lang: &quot;en&quot;, page: &quot;2&quot; &#125; 38. 拍平多维数组例如，调用 flatten([1, [2, 3], [4, [5, 6]]]) 将返回 [1, 2, 3, 4, 5, 6]。 function flatten(arr) &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])); &#125; else &#123; result.push(arr[i]); &#125; &#125; return result; &#125; function flatten(arr) &#123; return arr.reduce(function (flat, toFlatten) &#123; return flat.concat( Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten ); &#125;, []); &#125; 39. 数组去重以下是使用 JavaScript 编写的一个函数，可以对数组进行去重，包括三种不同的去重方法： function uniqueArray(arr) &#123; // 方法一：使用 Set 数据结构 const set = new Set(arr); const uniqueArr1 = [...set]; // 方法二：使用 indexOf() 方法 const uniqueArr2 = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (uniqueArr2.indexOf(arr[i]) === -1) &#123; uniqueArr2.push(arr[i]); &#125; &#125; // 方法三：使用 filter() 方法 const uniqueArr3 = arr.filter(function (item, index, array) &#123; return array.indexOf(item) === index; &#125;); return &#123; uniqueArr1, uniqueArr2, uniqueArr3 &#125;; &#125; 这个函数接收一个数组作为参数，并返回一个包含三种不同去重方法结果的对象。其中： 方法一使用了 ES6 中的 Set 数据结构，将数组转换为 Set，然后再将 Set 转换为数组。 方法二使用了 for 循环和 indexOf() 方法来遍历数组，如果元素在新数组中不存在，就将其添加到新数组中。 方法三使用了 filter() 方法来遍历数组，只保留第一次出现的元素。 40. vue2 声明周期函数在 Vue2 中，生命周期函数是 Vue 组件会经历的一系列依次触发的函数。它们在特定时候执行，并允许开发者执行响应逻辑。 这些生命周期函数主要包括以下几种: beforeCreate：在 Vue 实例初始化之后，数据观测和事件配置之前被调用。 表示含义：Vue 实例已经创建，但数据观测和事件还未设置。 执行时机：页面渲染前。 应用：这个阶段不能访问到 data、methods 等，通常用得较少。 new Vue(&#123; beforeCreate() &#123; console.log(&quot;beforeCreate&quot;); &#125;, &#125;); created：在 Vue 实例创建完成后被立即调用，此时已完成数据观测，方法和计算属性的运算。 表示含义：Vue 实例创建完成，数据观测以及 data、methods 等已设置。 执行时机：页面渲染前。 应用：可以用于转换数据格式、初始化、扩展 methods 方法等。 new Vue(&#123; data: &#123; message: &quot;Hello Vue!&quot;, &#125;, created() &#123; console.log(&quot;created&quot;); console.log(this.message); &#125;, &#125;); beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用。 表示含义：模板编译完成，但 DOM 还没有挂载。 执行时机：页面渲染前。 应用：一般不会在这个阶段操作，因为没有渲染出 DOM。 new Vue(&#123; el: &quot;#app&quot;, beforeMount() &#123; console.log(&quot;beforeMount&quot;); &#125;, &#125;); mounted：在 Vue 实例挂载完成时调用。此时已完成模板到 DOM 的挂载。 表示含义：完成 DOM 挂载，可以操作 DOM。 执行时机：页面渲染后。 应用：你可以在这里操作 DOM，比如插入插件或者调用接口。 new Vue(&#123; el: &quot;#app&quot;, mounted() &#123; console.log(&quot;mounted&quot;); &#125;, &#125;); beforeUpdate：数据发生变化时，且发生在虚拟 DOM 重新渲染和打补丁之前调用。 表示含义：数据已更新，但 DOM 还没有更新。 执行时机：页面更新前。 应用：可以在更新之前进行某些操作，比如离开当前页面前做个提示。 new Vue(&#123; data: &#123; message: &quot;Hello Vue!&quot;, &#125;, beforeUpdate() &#123; console.log(&quot;beforeUpdate&quot;); &#125;, &#125;); updated：在虚拟 DOM 重新渲染和打补丁后调用，表示 DOM 已完成更新。 表示含义：DOM 更新完成。 执行时机：页面更新后。 应用：可以执行依赖于 DOM 的操作，但要注意避免无限循环更新。 new Vue(&#123; data: &#123; message: &quot;Hello Vue!&quot;, &#125;, updated() &#123; console.log(&quot;updated&quot;); &#125;, &#125;); beforeDestroy：在 Vue 实例销毁之前调用。此时实例仍然可以完全正常使用。 表示含义：实例即将销毁，但仍可正常使用。 执行时机：销毁前。 应用：可以用来解绑事件或者清除定时器等。 new Vue(&#123; beforeDestroy() &#123; console.log(&quot;beforeDestroy&quot;); &#125;, &#125;); destroyed：在 Vue 实例销毁完成后调用。此时所有的绑定、实例方法等均已解除。表示含义：实例已完全销毁。执行时机：销毁后。应用：这个阶段实例已被销毁，很少会用到。 new Vue(&#123; destroyed() &#123; console.log(&quot;destroyed&quot;); &#125;, &#125;); 以上就是 Vue2 中的生命周期函数及其作用和应用。在实际项目中，我们可以根据不同需求选择合适的生命周期函数来执行相应操作。 41. vue2 父子组件生命周期调用顺序在 Vue2 中，父子组件的生命周期调用顺序如下： 挂载阶段（Mounting） 父组件：beforeCreate 父组件：created 父组件：beforeMount 子组件：beforeCreate 子组件：created 子组件：beforeMount 子组件：mounted 父组件：mounted 更新阶段（Updating） 父组件：beforeUpdate 子组件：beforeUpdate 子组件：updated 父组件：updated 卸载阶段（Unmounting） 父组件：beforeDestroy 子组件：beforeDestroy 子组件：destroyed 父组件：destroyed 42. vue2 keep-alive 组件在 Vue2 中，keep-alive 是一个抽象组件，它的作用是缓存非活动的组件实例，以避免反复重渲染，提高性能。 keep-alive 自身实际上不会渲染成一个 DOM 元素。 (1) 应用场景 列表切换渲染时：当有多个列表页面时，用户在不同的列表页面之间切换，需要保持每个列表页面的滚动位置、数据状态等。 页面级别的缓存：SPA 应用中，用户在不同页面之间切换时，需要保持一些页面的缓存，以提升性能并减少页面加载时间。 菜单切换渲染：当有多个菜单需要切换渲染时，为了保持之前菜单的状态，可以使用 keep-alive 来缓存这些菜单组件。 (2) 特有生命周期函数 activated：当被包裹的组件激活时，执行此钩子函数。这个钩子函数表示组件被缓存后，再次被渲染到页面时调用。 deactivated：当被包裹的组件被缓存时，执行此钩子函数。这个钩子函数表示组件被缓存时调用。 (3) 实现原理 keep-alive 的实现原理主要基于 Vue 的虚拟 DOM 和组件的生命周期函数。 当一个组件被包裹在 keep-alive 中时，keep-alive 会监听它的 activated 和 deactivated 钩子函数，缓存&#x2F;激活&#x2F;子组件。 keep-alive 使用了 Vue 的虚拟 DOM 实现，通过创建一个 &lt;keep-alive&gt; 的虚拟节点将对应组件的虚拟节点放入属性对应的缓存，为被包裹的组件额外添加 activated 和 deactivated 的生命周期处理，以达到激活和停用组件的目的。 当组件被激活时，keep-alive 会使用缓存中的组件 VNode 进行渲染，而不是重新创建一个新的 VNode。 这样，缓存的组件实例仍然保持之前的状态，不需要进行重新渲染。 当组件被停用时，keep-alive 会将其放入缓存，组件实例并未销毁，可用来再次激活组件。 可以使用 include 和 exclude 属性来指定哪些组件需要被缓存或排除。 (4) 示例代码 假设我们有两个组件： Home.vue 和 About.vue。当导航从 Home 组件切换到 About 组件时，我们希望保留 Home 组件的状态。 首先，创建两个组件文件：Home.vue 和 About.vue。 &lt;!-- Home.vue --&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;Home Page&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &quot;Home&quot;, &#125;; &lt;/script&gt; &lt;!-- About.vue --&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;About Page&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &quot;About&quot;, &#125;; &lt;/script&gt; 接下来，在App.vue文件中设置我们的路由视图以及keep-alive组件。 &lt;!-- App.vue --&gt; &lt;template&gt; &lt;div&gt; &lt;nav&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/template&gt; 然后，在router.js文件里配置我们的路由。 // router.js import Vue from &quot;vue&quot;; import Router from &quot;vue-router&quot;; import Home from &quot;./components/Home.vue&quot;; import About from &quot;./components/About.vue&quot;; Vue.use(Router); export default new Router(&#123; mode: &quot;history&quot;, routes: [ &#123; path: &quot;/&quot;, name: &quot;home&quot;, component: Home, &#125;, &#123; path: &quot;/about&quot;, name: &quot;about&quot;, component: About, &#125;, ], &#125;); 最后，在项目入口文件main.js中导入路由配置。 // main.js import Vue from &quot;vue&quot;; import App from &quot;./App.vue&quot;; import router from &quot;./router&quot;; Vue.config.productionTip = false; new Vue(&#123; router, render: (h) =&gt; h(App), &#125;).$mount(&quot;#app&quot;); 现在，当你在 Home 和 About 组件之间切换时，组件的状态应该被保留在 keep-alive 组件中。 43. vue2 生命周期与异步请求在 Vue2 中，可以执行异步请求的生命周期函数有以下几个： created：组件实例被创建后，在渲染 DOM 之前执行。 mounted：组件实例被挂载到 DOM 元素上之后执行。 updated：组件数据更新导致的虚拟 DOM 重新渲染后执行。 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave：在路由导航守卫中执行。 在这些生命周期里，通常推荐在 created 生命周期进行异步请求。理由如下： created 生命周期会在渲染 DOM 之前执行。这意味着，在数据请求返回前，可以进行其他的逻辑处理，例如展示加载状态等。 如果在 mounted 生命周期发起异步请求，可能会让用户在等待数据返回时看到一个空的页面，影响用户体验。 在 updated 生命周期发起异步请求会增加不必要的更新，因为每次数据更新都会触发这个生命周期。 通常情况下，我们需要根据具体需求调用和更新数据。 在路由导航守卫中进行异步请求适用于那些依赖特定路由参数的场景，如需要在页面跳转前获取数据。 综上，对于普通的异步请求推荐使用 created 生命周期。当然，在特定情况下，请根据具体需求选择合适的生命周期。 44. Vue2 v-if vs v-show在 Vue2 中，v-show 和 v-if 是两个用于条件渲染的指令。 下面分别介绍这两个指令的相同点和不同点，以及哪个指令的性能更好。 相同点： 都是用于条件渲染。v-show 和 v-if 这两个指令都可以根据条件去渲染或者隐藏某个 HTML 元素。 不同点： v-if 是”真正”的条件渲染指令，它会根据表达式的值在 DOM 树中插入或者删除对应的元素。 v-show 只是简单地切换元素的 CSS 属性 display，控制元素的显示和隐藏。 当表达式的值为 false 时，v-if 不会渲染元素到 DOM 树中 v-show 无论表达式的值为何始终都会渲染元素，在元素的 display 属性中设置为 none 来控制隐藏。 v-if 由于需要插入和删除 DOM 元素，当条件切换频繁时，对性能消耗较大。 v-show 只是简单地修改 CSS 属性，性能消耗较小。 如果需要频繁切换显示隐藏的场景，建议使用 v-show，因为它只需要修改 CSS 属性，性能开销较小。 如果元素不需要频繁切换，或者切换时需要重新获取数据、处理逻辑等，建议使用 v-if，因为它不会多次渲染不需要的元素，从而减少性能消耗。 45. v-for key问题：v-for 为什么要配合 key 一起使用？ 在 Vue2 中，v-for 和 key 被一起使用是出于性能优化的考虑，有助于提高列表渲染的性能。 v-for 指令是 Vue.js 中用于循环渲染列表元素的一个重要特性。在数据发生变化时，Vue 将更新 DOM 来匹配新的数据。 然而，有时候我们只是对列表进行简单的添加或删除操作，如果每次都重新计算整个列表并重新渲染，则会造成浪费，降低性能。 为解决此问题，Vue 实现了一种名为“就地复用”的策略。 当列表发生变化时，它会尽可能地减少重新创建和销毁 DOM 元素的次数。如果一个元素没有 key，Vue 将尝试使用 tag 复用现有元素。 然而，这种复用策略可能会导致一些问题。例如当列表元素的顺序发生变化时，它可能会导致不必要的更新，从而导致性能问题。 这时我们需要使用 key 属性来指定一个唯一标识符，使得 Vue 可以准确地识别每一个列表项。 key 属性应该为每一个列表项分配一个唯一的值，便于 Vue 知道如何对应新旧元素。 这样，当数据发生变化时，Vue 可以通过 key 属性来识别哪个元素被添加、修改或者删除，从而实现更有效的局部更新，提高列表渲染性能。 46. Vue2 组件通讯在 Vue2 中，我们可以使用以下方式实现组件之间的通信： (1) 父组件向子组件传递数据：通过 props &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;child-component :parent-data=&quot;data&quot;&gt;&lt;/child-component&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; components: &#123; ChildComponent, &#125;, data() &#123; return &#123; data: &quot;父组件数据&quot;, &#125;; &#125;, &#125;; &lt;/script&gt; &lt;!-- 子组件 --&gt; &lt;template&gt; &lt;div&gt;&#123;&#123; parentData &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; props: &#123; parentData: &#123; type: String, required: true, &#125;, &#125;, &#125;; &lt;/script&gt; (2) 子组件向父组件传递数据，通过自定义事件和 $emit &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;child-component @child-event=&quot;handleChildEvent&quot;&gt;&lt;/child-component&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; components: &#123; ChildComponent, &#125;, methods: &#123; handleChildEvent(payload) &#123; console.log(&quot;子组件传递的数据：&quot;, payload); &#125;, &#125;, &#125;; &lt;/script&gt; &lt;!-- 子组件 --&gt; &lt;template&gt; &lt;button @click=&quot;sendDataToParent&quot;&gt;发送数据至父组件&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default &#123; methods: &#123; sendDataToParent() &#123; this.$emit(&quot;child-event&quot;, &quot;来自子组件的数据&quot;); &#125;, &#125;, &#125;; &lt;/script&gt; (3) 兄弟组件之间通信需要通过共同的父组件，或者使用事件总线（Event Bus） 首先创建一个新的事件总线实例： // event-bus.js import Vue from &quot;vue&quot;; export const EventBus = new Vue(); 组件 A 发送数据至组件 B： &lt;template&gt; &lt;button @click=&quot;sendDataToSibling&quot;&gt;发送数据至兄弟组件&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import &#123; EventBus &#125; from &quot;@/event-bus.js&quot;; export default &#123; methods: &#123; sendDataToSibling() &#123; EventBus.$emit(&quot;sibling-event&quot;, &quot;来自组件 A 的数据&quot;); &#125;, &#125;, &#125;; &lt;/script&gt; 组件 B 接收数据： &lt;template&gt; &lt;div&gt;接收到的数据：&#123;&#123; receivedData &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import &#123; EventBus &#125; from &quot;@/event-bus.js&quot;; export default &#123; data() &#123; return &#123; receivedData: null, &#125;; &#125;, created() &#123; EventBus.$on(&quot;sibling-event&quot;, this.handleSiblingData); &#125;, beforeDestroy() &#123; EventBus.$off(&quot;sibling-event&quot;, this.handleSiblingData); &#125;, methods: &#123; handleSiblingData(payload) &#123; this.receivedData = payload; &#125;, &#125;, &#125;; &lt;/script&gt; 注意：使用事件总线时，不要忘记在组件销毁时移除对应的事件监听，避免内存泄漏。 47. v-model 的实现原理Vue.js 中的 v-model 是实现表单控件与数据双向绑定的指令。 其实现原理主要基于两个部分：数据到视图的绑定（数据驱动视图更新）和视图到数据的绑定（视图驱动数据更新）。 数据到视图的绑定：当数据发生变化时，通过数据劫持（Vue.js 2.x 使用 Object.defineProperty，Vue.js 3.x 使用 Proxy）触发数据变化的侦听函数，然后通过订阅者模式通知相应的指令更新，最后视图更新。 视图到数据的绑定：当用户与视图交互（如输入文本、选择选项等）时，通过监听视图的 input 事件，获取视图的最新值，然后将其赋值给相应的数据，实现视图到数据的绑定。 下面是一个 Vue.js 的代码示例： &lt;template&gt; &lt;div&gt; &lt;!-- 使用 v-model 进行双向数据绑定 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;&quot;, &#125;; &#125;, &#125;; &lt;/script&gt; 在这个示例中，我们使用 v-model 指令将输入框与 data 中的 message 属性进行双向绑定。当用户输入文本时，视图到数据的绑定将用户的输入赋值给 message 属性；同时，数据到视图的绑定会自动将 message 的最新值更新到视图上，展示在 &lt;p&gt; 标签中。 在原生 JavaScript 中，你可以使用事件监听器和数据代理来实现一个简单的双向数据绑定。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt; &lt;p id=&quot;output&quot;&gt;&lt;/p&gt; &lt;script&gt; // 1. 获取 DOM 元素 const input = document.getElementById(&quot;input&quot;); const output = document.getElementById(&quot;output&quot;); // 2. 初始化一个数据对象 let data = &#123; value: &quot;&quot;, &#125;; // 3. 代理数据对象，监听数据变化 const proxy = new Proxy(data, &#123; set(target, key, value) &#123; target[key] = value; // 更新 DOM output.innerText = value; return true; &#125;, &#125;); // 4. 监听 input 事件，并更新数据对象 input.addEventListener(&quot;input&quot;, (e) =&gt; &#123; proxy.value = e.target.value; &#125;); // 初始更新 proxy.value = &quot;&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这个示例中，我们创建了一个简单的数据代理，使用 Proxy 对象来代理一个初始数据对象并在数据对象的值被设置时更新 DOM。然后，我们使用事件监听器监听 input 元素的输入事件，并在输入值发生变化时更新数据代理对象的值。通过这样的方式，我们实现了一个简单的双向数据绑定。 48. 如何理解 MVVMMVVM（Model-View-ViewModel）模式是一种软件架构设计模式，主要用于分离应用程序的界面表示层（View）和业务逻辑层（Model）。它的核心思想是基于数据驱动的视图更新。ViewModel 作为 View 和 Model 之间的连接器，负责将 Model 中的数据转换成 View 可以显示的数据，并处理从 View 接收到的用户交互事件。MVVM 让应用程序的不同部分更容易分离、测试和维护。 MVVM 的优点如下： 解耦：MVVM 模式可以将 UI（用户界面）和业务逻辑分离，在一定程度上简化了代码编写和程序设计。 双向数据绑定：ViewModel 和 View 之间的数据同步是自动完成的，这意味着当数据发生变化时，不需要手动更新视图，从而减少了很多重复和繁琐的工作。 可维护性：由于 UI 和业务逻辑分离，维护成本较低。当需要更新视图或业务逻辑时，可以只关注对应的部分，而不会对其他部分产生影响。 可测试性：可以对 ViewModel 进行单元测试，提高应用程序的可靠性和健壮性。 可重用性：可以重用 ViewModel 中的代码，提高开发效率。 MVVM 的缺点如下： 过度抽象：当应用程序的功能或逻辑不是很复杂时，MVVM 可能会导致过度抽象，增加了代码的复杂性和学习成本。 内存占用：由于持续监听数据变化和双向绑定，可能导致更高的内存占用和性能损失。 依赖框架：为实现 MVVM，通常需要依赖于特定的框架（如：Vue.js、Angular、React 等），在某种程度上限制了技术选型。 总结一下，MVVM 为前端应用带来了更好的可维护性、可测试性和解耦。它尤其适用于复杂数字、逻辑复杂的大型应用程序。但对于简单的应用程序来说，可能会导致过度抽象和依赖于特定框架。 在 JavaScript 中，Object.create() 是一个用于创建新对象的方法。它是基于现有对象创建新对象的一种方式，新对象可以继承现有对象的属性和方法。 使用 Object.create() 方法时，需要传入一个原型对象作为参数。该方法将返回一个新对象，该对象的原型是传入的原型对象。这个新对象可以通过访问原型对象来获取属性和方法。 以下是一个简单的示例，说明如何使用 Object.create() 方法： // 定义一个原型对象 let person = &#123; name: &quot;John&quot;, age: 30, greeting: function () &#123; console.log( &quot;Hello, my name is &quot; + this.name + &quot; and I am &quot; + this.age + &quot; years old.&quot; ); &#125;, &#125;; // 使用 Object.create() 方法创建一个新对象 let student = Object.create(person); // 设置新对象的属性 student.name = &quot;Jane&quot;; student.age = 20; // 调用新对象的方法 student.greeting(); // 输出：Hello, my name is Jane and I am 20 years old. 在这个示例中，我们首先定义了一个名为 person 的原型对象，它有三个属性：name、age 和 greeting。然后，我们使用 Object.create() 方法创建了一个名为 student 的新对象，并将 person 对象作为其原型。最后，我们设置了 student 对象的 name 和 age 属性，并调用了其 greeting() 方法。 需要注意的是，使用 Object.create() 方法创建的新对象并不具有自己的属性和方法，它们都是从原型对象继承而来的。如果需要添加新的属性或方法，可以直接在新对象上定义。 49 computed 计算属性Vue 中的计算属性（Computed properties）是一种特殊类型的属性，它依赖其他属性值的变化进行自动计算和更新。 计算属性的主要作用是将一些复杂的逻辑和计算放入独立的属性中，使 Vue 模板更简洁、可读性更强。 计算属性具有以下特性： 响应式依赖：计算属性依赖其他响应式属性值，当依赖属性值发生变化时，计算属性自动更新。 缓存优化：计算属性具有缓存机制，只有当依赖的属性值发生变化时，计算属性才重新计算值。否则，直接使用缓存的值。 可读性：通过计算属性可以将复杂数值计算和转换逻辑移到独立的属性中，使 Vue 模板更简洁、便于理解和维护。 支持 getter 和 setter：计算属性默认只有 getter 方法，但也可以指定一个 setter 方法，实现对计算属性的赋值操作。 实际项目中，计算属性的应用主要包括： 动态计算属性值：当一个属性值依赖于其他属性值时，可以使用计算属性。 格式化显示数据：当需要对数据进行格式化或转换时，可以使用计算属性。 过滤数组或对象：当需要根据一定条件筛选出数据列表或对象的子集时，可以使用计算属性。 以下是一个代码示例： &lt;template&gt; &lt;div&gt; &lt;input v-model=&quot;firstName&quot; placeholder=&quot;First Name&quot; /&gt; &lt;input v-model=&quot;lastName&quot; placeholder=&quot;Last Name&quot; /&gt; &lt;p&gt;Full name: &#123;&#123; fullName &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, &#125;; &#125;, computed: &#123; // 计算属性 fullName 依赖于 firstName 和 lastName fullName() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;, &#125;, &#125;; &lt;/script&gt; 在这个示例中，我们有两个输入框，用于填写名和姓。我们定义了一个计算属性 fullName，它的值依赖于 firstName 和 lastName。当我们在输入框中更改名字或姓氏时，fullName 自动更新，显示完整的名字。这使我们的模板非常简洁，便于理解。 50. vue data 函数为什么 vue 中的 data 配置项必须是一个函数? 在 Vue 中，data 配置项必须是一个函数，主要原因是为了避免组件实例之 4 据。 若不是一个函数，那么所有组件实例将引用相同的数据对象，这样当其中一个组件实例改变数据时，其他组件实例中的数据也将受到影响。 假设我们有一个简单的组件，用于显示一个计数器： Vue.component(&quot;counter&quot;, &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; count: 0, &#125;; &#125;, &#125;); 我们将 data 配置项定义为一个函数，它返回一个对象，包含该组件实例的初始数据。 在这个例子中，我们为每个 counter 组件实例定义了一个 count 属性，并将其初始值设置为 0。 当我们在应用程序中多次使用 counter 组件时： &lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; 每个组件实例都会拥有自己独立的 count 数据。可以想象，如果我们将 data 直接定义为一个对象，如下所示： Vue.component(&quot;counter&quot;, &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, data: &#123; count: 0, &#125;, &#125;); 那么所有的 counter 组件实例将共享同一个 count 数据，并且当一个实例的 count 值发生变化时，其他实例的 count 值也会受到影响。 因此，将 data 定义为一个函数，确保了每个组件实例都能拥有独立的数据副本，从而避免了潜在的问题。 51. vue2 抽取逻辑如何将多个组件中的公共逻辑抽取出来？ 在 Vue2 中，有两种主要的方式可以将多个组件中的相同逻辑抽取出来： Mixins（混入） 和高阶组件（Higher-Order Components，简称 HOC）。 Mixins（混入） Mixins 是一种在多个组件之间共享可复用的功能的方法。一个 mixin 的方法可以被其他组件混入，这样这些组件就可以获得 mixin 中定义的数据、组件、指令、生命周期方法等。 假设我们有以下相同逻辑需要在多个组件中使用： // commonLogic.js export default &#123; data() &#123; return &#123; message: &quot;Hello from mixin!&quot;, &#125;; &#125;, created() &#123; console.log(this.message); &#125;, methods: &#123; showAlert() &#123; alert(this.message); &#125;, &#125;, &#125;; 在其他组件中使用 Mixin： // ComponentA.vue import commonLogic from &quot;./commonLogic.js&quot;; export default &#123; mixins: [commonLogic], // ... &#125;; // ComponentB.vue import commonLogic from &quot;./commonLogic.js&quot;; export default &#123; mixins: [commonLogic], // ... &#125;; 高阶组件（Higher-Order Components） 高阶组件（HOC）是一个接收组件作为参数并返回一个新组件的函数。该新组件包含了原组件的所有功能，并且可以向原组件注入新的逻辑。 // withCommonLogic.js export default function withCommonLogic(WrappedComponent) &#123; return &#123; name: `withCommonLogic($&#123;WrappedComponent.name&#125;)`, data() &#123; return &#123; message: &quot;Hello from HOC!&quot;, &#125;; &#125;, created() &#123; console.log(this.message); &#125;, methods: &#123; showAlert() &#123; alert(this.message); &#125;, &#125;, render(h) &#123; return h(WrappedComponent, &#123; props: this.$props, on: this.$listeners, scopedSlots: this.$scopedSlots, &#125;); &#125;, &#125;; &#125; 在其他组件中使用 HOC： // ComponentA.vue import withCommonLogic from &quot;./withCommonLogic.js&quot;; export default withCommonLogic(&#123; name: &quot;ComponentA&quot;, // ... &#125;); // ComponentB.vue import withCommonLogic from &quot;./withCommonLogic.js&quot;; export default withCommonLogic(&#123; name: &quot;ComponentB&quot;, // ... &#125;); 以上两种方法都可以在 Vue2 中将多个组件中的相同逻辑抽取出来。你可以根据具体的需求和项目场景决定使用哪种方式。 52. vue2 异步组件异步组件在 Vue.js 中可以帮助我们实现代码分割和按需加载，优化性能和加载速度。这对于大型应用程序是非常有用的。以下是 4 个场景的例子： (1) 路由懒加载 可以把某个路由对应的组件编写成异步组件，这样在初始加载时，只需要加载首页的组件，其他页面的组件可以在实际访问时按需加载。 import Vue from &quot;vue&quot;; import Router from &quot;vue-router&quot;; Vue.use(Router); const Foo = () =&gt; import(&quot;@/components/Foo.vue&quot;); const Bar = () =&gt; import(&quot;@/components/Bar.vue&quot;); export default new Router(&#123; routes: [ &#123; path: &quot;/foo&quot;, component: Foo &#125;, &#123; path: &quot;/bar&quot;, component: Bar &#125;, ], &#125;); (2) 按需加载弹窗组件 某些场景下，我们需要在用户点击某个按钮后展示一个弹窗组件。这种组件在页面加载时可能并不需要，可以使用异步组件按需加载。 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;openModal&quot;&gt;打开弹窗&lt;/button&gt; &lt;Modal v-if=&quot;showModal&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const Modal = () =&gt; import(&quot;@/components/Modal.vue&quot;); export default &#123; data() &#123; return &#123; showModal: false, &#125;; &#125;, components: &#123; Modal &#125;, methods: &#123; openModal() &#123; this.showModal = true; &#125;, &#125;, &#125;; &lt;/script&gt; (3) 大型选项卡式应用 在一个包含多个选项卡的应用中，可以将每个选项卡对应的组件编写为异步组件，这样可以在切换选项卡时按需加载相应的组件。 &lt;template&gt; &lt;div&gt; &lt;tabs&gt; &lt;tab name=&quot;A&quot; :component=&quot;A&quot;&gt;&lt;/tab&gt; &lt;tab name=&quot;B&quot; :component=&quot;B&quot;&gt;&lt;/tab&gt; &lt;tab name=&quot;C&quot; :component=&quot;C&quot;&gt;&lt;/tab&gt; &lt;/tabs&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const A = () =&gt; import(&quot;@/components/A.vue&quot;); const B = () =&gt; import(&quot;@/components/B.vue&quot;); const C = () =&gt; import(&quot;@/components/C.vue&quot;); export default &#123; components: &#123; A, B, C, &#125;, &#125;; &lt;/script&gt; (4) 根据不同设备加载不同组件 当我们需要根据不同设备展示不同的组件时，可以在运行时动态加载相应的异步组件。 &lt;template&gt; &lt;div&gt; &lt;component :is=&quot;currentComponent&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const DesktopComponent = () =&gt; import(&quot;@/components/DesktopComponent.vue&quot;); const MobileComponent = () =&gt; import(&quot;@/components/MobileComponent.vue&quot;); export default &#123; data() &#123; return &#123; currentComponent: null, &#125;; &#125;, created() &#123; if (window.innerWidth &lt; 768) &#123; this.currentComponent = MobileComponent; &#125; else &#123; this.currentComponent = DesktopComponent; &#125; &#125;, &#125;; &lt;/script&gt; 53. vue 作用域插槽Vue 中的作用域插槽（Scoped Slots）是一种特殊类型的插槽，它允许父组件向子组件传递数据，同时还允许子组件在其插槽中使用该数据。这使得子组件可以更灵活地渲染父组件传递的数据，而不仅仅是简单地显示它们。 &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;child-component&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.message &#125;&#125; World! &lt;/template&gt; &lt;/child-component&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; components: &#123; ChildComponent, &#125;, &#125;; &lt;/script&gt; &lt;!-- 子组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot :message=&quot;message&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;Hello&quot;, &#125;; &#125;, &#125;; &lt;/script&gt; 在这个示例中，父组件包含一个名为 child-component 的子组件。父组件使用 v-slot 指令来定义一个默认插槽，并将其绑定到一个名为 slotProps 的变量上。该变量是一个对象，其中包含子组件需要使用的数据。在这种情况下，子组件需要使用名为 message 的数据。 子组件包含一个名为 message 的数据属性，并将其传递给插槽。父组件中的模板使用 slotProps.message 来访问该数据，并将其与字符串 World!连接起来。 54. vuex action mutation在 Vuex 中，mutation 和 action 都是用于管理应用程序状态的重要概念。 它们的作用是不同的，mutation 用于修改状态，而 action 用于处理异步逻辑。 mutation 是 Vuex 中用于修改状态的方法。它们必须是同步的，这意味着它们不能包含异步逻辑。mutation 只能通过提交(commit)来调用。 下面是一个简单的示例： const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;, &#125;); store.commit(&quot;increment&quot;); action 是 Vuex 中用于处理异步逻辑的方法。它们可以包含任何异步代码，例如 API 调用或 setTimeout()函数。action 可以通过 dispatch 来调用。 const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;, actions: &#123; incrementAsync(context) &#123; setTimeout(() =&gt; &#123; context.commit(&quot;increment&quot;); &#125;, 1000); &#125;, &#125;, &#125;); store.dispatch(&quot;incrementAsync&quot;); 55. vue router 路由模式Vue Router 提供了三种路由模式：hash 模式、history 模式和 abstract 模式。 (1) Hash 模式 Hash 模式使用 URL 的 hash 部分（即#号后面的内容）来管理路由。在这种模式下，当 URL 的 hash 部分发生变化时，Vue Router 会自动更新视图。Hash 模式不需要服务器配置，因此它非常适合在静态文件服务器上部署单页应用程序。 const router = new VueRouter(&#123; mode: &#39;hash&#39;, routes: [...] &#125;) (2) History 模式 History 模式使用 HTML5 History API 来管理路由。在这种模式下，URL 的路径部分被用来管理路由。当 URL 的路径部分发生变化时，Vue Router 会自动更新视图。History 模式需要服务器配置，以便在用户直接访问页面时正确地响应请求。 const router = new VueRouter(&#123; mode: &#39;history&#39;, routes: [...] &#125;) (3) Abstract 模式 Abstract 模式不会改变浏览器的 URL，而是将路由信息保存在内存中。这种模式常用于服务器端渲染或单元测试中。 const router = new VueRouter(&#123; mode: &#39;abstract&#39;, routes: [...] &#125;) 在选择路由模式时，需要考虑以下几个因素： 服务器配置：如果你的应用程序需要在服务器上运行，则需要选择支持 HTML5 History API 的路由模式。 SEO 优化：如果你的应用程序需要进行 SEO 优化，则需要选择支持 HTML5 History API 的路由模式。 兼容性：如果你的应用程序需要在旧版浏览器上运行，则需要选择支持 Hash 模式的路由模式。 综上所述，选择哪种路由模式取决于你的应用程序的需求和服务器配置。 在大多数情况下，我们建议使用 History 模式，因为它可以提供更好的用户体验和 SEO 优化。 55. JavaScript 模拟前端路由前端路由可以通过监听 URL 的变化，并根据 URL 的不同渲染不同的视图来实现。下面是使用 JavaScript 模拟前端路由的示例代码： const routes = &#123; &quot;/&quot;: home, &quot;/about&quot;: about, &quot;/contact&quot;: contact, &#125;; const content = document.querySelector(&quot;.content&quot;); function render(path) &#123; content.innerHTML = routes[path]; &#125; function router() &#123; const path = window.location.pathname; render(path); &#125; window.addEventListener(&quot;popstate&quot;, router); document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; document.body.addEventListener(&quot;click&quot;, (e) =&gt; &#123; if (e.target.tagName === &quot;A&quot;) &#123; e.preventDefault(); const href = e.target.getAttribute(&quot;href&quot;); window.history.pushState(null, null, href); router(); &#125; &#125;); router(); &#125;); 在这个示例中，我们首先定义了一个 routes 对象，其中包含了不同路径对应的视图。 然后，我们定义了一个 render 函数，用于根据 URL 渲染不同的视图。 接下来，我们定义了一个 router 函数，用于监听 popstate 事件并根据 URL 的变化渲染不同的视图。我们还在 DOMContentLoaded 事件中添加了一个事件监听器，用于处理用户点击链接时的行为。当用户点击链接时，我们使用 pushState 方法将新的 URL 添加到浏览器历史记录中，并调用 router 函数来渲染新的视图。 最后，在 DOMContentLoaded 事件中调用 router 函数来初始化路由，并开始监听 popstate 事件的触发。 需要注意的是，这只是一个简单的示例代码，实际的前端路由实现可能需要更复杂的逻辑和处理。 在 JavaScript 中，执行顺序是由事件循环（Event Loop）来实现的。事件循环中主要有两种任务：宏任务（Macro-task）和微任务（Micro-task）。DOM 渲染通常在宏任务和微任务之间执行。 执行顺序如下： 首先处理宏任务（例如整个 script 代码执行完毕） 完成 DOM 渲染。 处理微任务队列中的所有微任务 进行下一轮的宏任务（例如 setTimeout） 依赖注入（Dependency Injection，简称 DI）是一种软件设计模式，它通过将对象的依赖关系从对象内部解耦，使得对象实例在运行时可以更加灵活地接收依赖项。依赖注入主要有以下好处： 提高了代码的可维护性，使得组件之间的耦合度降低。 提高了代码的可测试性，因为依赖关系可以根据测试需求动态注入。 下面举一个简单的 TypeScript 代码例子说明依赖注入的工作方式。 假设我们需要为一个电子商务系统设计一个购物车功能。购物字功能内部需要调用一系列子服务，例如库存服务、付款服务和邮寄服务。 // 定义子服务 interface IStockService &#123; checkStock(product: string): boolean; &#125; interface IPayService &#123; pay(amount: number): boolean; &#125; interface IShippingService &#123; ship(products: string[], address: string): boolean; &#125; // 创建依赖于子服务的购物车类 class ShoppingCart &#123; private stockService: IStockService; private payService: IPayService; private shippingService: IShippingService; constructor( stockService: IStockService, payService: IPayService, shippingService: IShippingService ) &#123; this.stockService = stockService; this.payService = payService; this.shippingService = shippingService; &#125; purchase(products: string[], address: string): boolean &#123; for (const product of products) &#123; if (!this.stockService.checkStock(product)) &#123; console.log(`库存不足: $&#123;product&#125;`); return false; &#125; &#125; const amount = products.length * 10; if (!this.payService.pay(amount)) &#123; console.log(&quot;付款失败&quot;); return false; &#125; if (!this.shippingService.ship(products, address)) &#123; console.log(&quot;邮寄失败&quot;); return false; &#125; console.log(&quot;购物成功&quot;); return true; &#125; &#125; 在这个例子中，购物车类（ShoppingCart）的实例需要接收三个子服务实例作为创建实例的输入。这样做的好处是： 查看购物车类，可以很明显地看到它依赖于哪些子服务，便于理解和维护。 在运行时，可以根据需要灵活地为购物车类注入不同版本的子服务，例如在测试环境中使用模拟数据的子服务。 为了完成依赖注入，你需要创建子服务的实现类并将它们传递给购物车类。例如，你可以这样使用购物车类： // 定义子服务的实现类 class StockService implements IStockService &#123; checkStock(product: string): boolean &#123; return true; // 在实际项目中，此处应从数据库或其他来源检查库存 &#125; &#125; class PayService implements IPayService &#123; pay(amount: number): boolean &#123; return true; // 在实际项目中，此处应调用支付接口完成付款 &#125; &#125; class ShippingService implements IShippingService &#123; ship(products: string[], address: string): boolean &#123; return true; // 在实际项目中，此处应调用物流接口完成邮寄 &#125; &#125; // 实例化子服务 const stockService = new StockService(); const payService = new PayService(); const shippingService = new ShippingService(); // 依赖注入：实例化购物车类，并将子服务的实例注入 const shoppingCart = new ShoppingCart( stockService, payService, shippingService ); shoppingCart.purchase([&quot;product-1&quot;, &quot;product-2&quot;], &quot;北京市海淀区&quot;); 在这个例子中，我们首先实现了子服务的实现类，接着创建了子服务的实例，最后将他们注入到购物车类中。这样就实现了购物车类对子服务的灵活依赖。","categories":[],"tags":[]},{"title":"React专题","slug":"React专题","date":"2023-06-01T02:49:58.239Z","updated":"2023-06-01T02:50:13.941Z","comments":true,"path":"2023/06/01/React专题/","link":"","permalink":"https://eathl.github.io/2023/06/01/React%E4%B8%93%E9%A2%98/","excerpt":"","text":"如何创建 React 项目20qz-pylcc npm install create-react-app -g create-react-app ./react-basic cd react-basic npm start npm init react-app ./react-basic 如何理解 JSX JSX 是 Facebook 创建的 JavaScript 语法扩展,React 中使用 JSX 来构建用户界面. 在使用 JSX 时有哪些注意事项 1. JSX 必须有根元素 &lt;&gt;&lt;/&gt; 2. 单标记必须闭合 &lt;img src=&quot;&quot; /&gt; 3. 在 JSX 的外部可以加上小括号用于美化其对其方式 4. 只有表达式才可以嵌入到 JSX 中, 非表达式不可以 if else for switch 5. 属性名称遵循驼峰式命名法 6. Null undefined true false 可以被渲染 但是渲染的结果是空 7. JSX 中不能直接渲染对象 8. 使用 className 替换 class、使用 htmlFor 替换 for 如何将对象类型的数据直接嵌入 JSX 中 要将对象转换为对象的字符串格式才可以。JSON.stringify(obj) 什么是条件渲染, 在 React 中有哪些手段可以实现条件渲染。 根据条件决定渲染什么内容 if 三元运算 逻辑运算 如何实现列表渲染 1. 先通过 map 方法将纯数据数组转换为 JSX 数组 2. 将 JSX 数组放入插入表达式中让其自动展开 在 React 中如何使用本地图片 import img from &quot;some/path&quot;; const img = require(&quot;some/path&quot;); &lt;img src=&#123;img&#125; /&gt; 简要说明如何为元素绑定事件 事件名称采用驼峰式命名法, 将事件名称直接作为属性添加到元素的身上 事件名称对应的值,就是事件处理函数本身 &lt;element onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;&lt;/element&gt; 什么是组件、组件为开发者带来了哪些好处 组件就是可以被组合的零部件, React 采用组件化的方式构建用户界面 就是将一个完整的页面拆分成一个一个小的部分再组合 一个组件就是页面中的一小块区域, 要包含 html 结构、css 样式、javascript 逻辑 React 中有两种组件：函数式组件和class组件。 如何为组件添加组件级样式 1. 创建样式表文件, 文件名称必须以 .module.css 结尾, 名称前面一般约定写组件名称, 比如 App.module.css 2. 在组件中通过 import styles from &quot;./App.module.css&quot; 的方式导入样式表 3. 在组件中通过 className 使用样式表中的样式 &lt;element className=&#123;styles.样式表中的类名&#125;/&gt; 类组件如何声明组件状态、如何获取组件状态、如何修改组件状态 将组件状态存储到 state 属性中, state 属性的值是对象类型, 对象中的属性就是状态 在 render 方法中: this.state.状态 this.setState() 类组件中的 constructor 方法、render 方法中的 this 指向谁? 当前类的实例对象 如何使事件处理函数中的 this 指向当前组件的实例对象 1. 将事件处理函数更改为箭头函数 2. 使用 bind 更改事件处理函数中的this 3. &lt;element onClick=&#123;() =&gt; this.clickHandler()&#125; /&gt; 在类组件中如何获取 DOM 对象 import &#123; createRef &#125; from &quot;react&quot;; class App extends React.Component &#123; divRef = createRef(); render() &#123; return &lt;div ref=&#123;divRef&#125; onClick=&#123;() =&gt; console.log(divRef.current)&#125;&gt;&lt;/div&gt; &#125; &#125; 什么是受控表单、如何实现受控表单 表单的值由组件状态进行控制, 用户在表单中实时输入的时候, 我们要将用户输入的内容同步到组件状态之中, 开发者要想获取表单值, 只需要从组件状态中进行获取即可. class App extends React.Component &#123; state = &#123; text: &quot;&quot; &#125; render() &#123; return &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onChange=&#123;(event) =&gt; this.setState(&#123;text: event.target.value&#125;)&#125;/&gt; &#125; &#125; 什么是组件通讯 数据能够在不同的组件之间进行流动。 父组件能够将自己的状态传递到子组件, 子组件可以修改父组件中定义的状态 如果向组件内部传递数据、如何在组件内部获取数据 通过组件属性的方式(props) &lt;App name=&quot;张三&quot;/&gt; class App extends React.Component &#123; render() &#123; this.props.name &#125; &#125; 什么是单向数据流动 数据在组件之间进行流动的时候, 方向只能是从上到下, 也就是说, 只能上层组件中的数据传递到下层组件 使数据流动变得简单, 程序更加好维护. props 为什么是只读的. 为了实现单向实现数据流动, 如果 props 不是只读的, 是可以修改的, 那么单向数据流动将无法实现. 在子组件中如何更新父组件中的状态 父组件定义修改状态的方法, 父组件将修改状态的方式传递到子组件, 子组件通过父组件传递下来的方法进行状态的修改。 如何实现兄弟组件通讯 利用状态提升思想, 将兄弟组件之间需要共享的状态提供至它们之间公共的父级中, 然后通过 props 的方式再将状态分别传递到兄弟组件中. 如何实现跨级组件通讯20qz-pylcc 利用上下文对象实现. import &#123; createContext &#125; from &quot;react&quot;; // Provider 用来保存状态并提供状态 // Consumer 用来获取状态 const &#123; Provider, Consumer &#125; = createContext(); &lt;Provider value=&#123;&#123;name: \"张三\"&#125;&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;Consumer&gt; &#123; (value) =&gt; &lt;div&gt;&#123;value.name&#125;&lt;/div&gt; &#125; &lt;/Consumer&gt; 组件属性校验的意义是什么 1. 防止组件的调用者传递错误的属性值类型, 导致组件内部的代码执行出错 2. 当组件的调用者传递了错误的属性值时, 给组件的调用者更加精准的错误提示 npm install prop-types import PropTypes from &quot;prop-types&quot;; class App extends React.Component &#123; static propTypes = &#123; colors: PropTypes.array.isRequired &#125; &#125; 什么是组件属性的默认值 我们在定义组件的时候, 可以为即将接收的外部数据设置默认值, 组件的调用者在传值的情况下组件使用调用者传递的值, 没传就是用默认值, 这样可以防止组件代码执行出错. class App extends React.Component &#123; static defaultProps = &#123;&#125;; &#125; 什么是组件的生命周期 从组件创建到销毁, 它经历的整个过程被称之为组件的生命周期. 开发者通过组件生命周期函数将业务逻辑插入到组件运行的各个阶段. 所谓生命周期函数就是 React 提供的一些固定名字的函数, 在组件运行的各个阶段被自动调用. React 类组件中组件生命周期函数有几大阶段, 分别对应哪些常见的生命周期函数 1. 挂载阶段 创建组件、渲染组件视图 constructor render componentDidMount constructor: 做一些初始化的工作, 比如更改组件中的函数的this 指向、初始化状态对象、创建引用对象、创建业务逻辑需要的公共属性 render: 渲染视图、不能直接调用 setState 更新状态 componentDidMount: 操作DOM、发送网络请求、更新组件状态 2. 更新阶段 1. 什么情况下会触发组件更新 1. 组件状态发生变化 2. 父组件更新 3. 强制更新 forceUpdate 2. render componentDidUpdate componentDidUpdate: 操作DOM、发送网络请求、有条件的更新组件状态 3. 卸载阶段 componentWillUnMount 清理操作、清除定时器、清除事件、清除订阅、清除全局状态 页面初始渲染时要请求的数据要写在哪个生命周期函数中 componentDidMount 组件卸载之前需要干些什么事情 清理操作、清除定时器、清除事件、清除订阅、清除全局状态 在调用 setState 方法时传递对象作为参数和传递函数作为参数主要的区别在哪 区别主要体现在同时多次调用 setState 方法时, 传递对象在做状态合并时, 它是覆盖式合并, 传递函数时, 它是累计性合并. this.setState(&#123;count: 1&#125;) this.setState(&#123;count: 1&#125;) this.setState((state) =&gt; (&#123;count: state.count + 1&#125;)) this.setState((state) =&gt; (&#123;count: state.count + 1&#125;)) 为什么在调用 setState 方法之后不能立即获取到更新之后的状态值 在 React 中，当调用 setState 方法更新组件的状态时，React 并不会立即更新组件的状态，而是会将状态更新请求放入更新队列中，以便在适当的时候进行更新。这是因为 React 会将多个 setState 方法调用进行合并，以提高性能和优化更新。 因此，如果在调用 setState 后立即尝试访问状态值，可能会得到之前的状态值，因为此时更新队列尚未被处理。如果需要在更新完成后访问更新后的状态值，可以使用 setState 的第二个参数，即回调函数。回调函数会在组件状态更新完成后被调用，可以在回调函数中访问更新后的状态值。 this.setState(&#123;count: this.state.count + 1&#125;, () =&gt; &#123; console.log(this.state.count); // 在回调函数中访问更新后的状态值 &#125;); 什么是浅比较 在 React 中，当一个组件的状态或属性更新时，React 会进行一个称为“比较”的过程来确定是否需要重新渲染组件。浅比较是 React 中一种比较对象的方式，用于检查两个对象是否相等。 浅比较只会比较对象的引用，而不会比较对象的值。如果两个对象的引用不同，即使它们的值相同，浅比较也会认为它们是不相等的。如果两个对象的引用相同，即使它们的值已经发生了变化，浅比较仍然认为它们是相等的。 PureComponent 类的作用是什么 可以防止组件的无效渲染. 在组件即将更新之前, PureComponent 会拿着上一次更新组件时使用的 props 和 即将更新组件时使用的 prop 进行比较 如果比较结果是相同的, 阻止组件渲染, 因为即使重新渲染, 得到的最终结果也是一样的. shouldComponentUpdate 生命周期函数的作用是什么 通过 shouldComponentUpdate 生命周期函数的返回值可以决定组件是否继续更新. true 继续更新 false 阻止更新. 组件状态管理存在什么问题 当组件与组件之间要进行状态共享的时候, 状态需要在不同的组件之间通过 props 的方式进行传递, 传递过程非常复杂. 和组件状态管理相比, 全局状态管理有什么优势 全局状态管理是指将状态存储到一个脱离于组件的地方进行管理, 所有组件都可以直接获取状态, 直接修改状态, 避免了组件状态管理中的 状态需要在不同的组件之间进行传递的复杂过程. 简要描述 Redux 管理状态的模式 在 Redux 中通过 store 对象进行状态的管理, store 对象可以存储状态, 有提供了管理状态的方法. 通过 store.getState 获取状态, 通过 store.dispatch 修改状态, 通过 store.subscribe 订阅状态的变化. 在 Redux 中对状态进行的任何修改都需要通过 action 对象进行描述, action 对象中有 type 属性, 它就是具体的用来描述的属性 视图中要想修改状态, 必须调用 dispatch 方法接收 action 对象, 该命令会被 reducer 函数接收, 在 reducer 函数要对 action.type 进行匹配 根据 action 的类型对状态进行不同的处理, 处理完成之后要返回, 给 store 进行存储. 在 Redux 中通过什么方法创建 store 对象, 并描述该方法的使用方式 const store = createStore(reducer, initialState) 描述 action 对象的作用是什么、什么是 action creator、为什么会有 action creator 这样的概念 在 Redux 中, action 对象用于描述当前要对状态进行怎样的操作, 它就是一个命令, 通过 dispatch 进行发送. action creator 就是一个用于返回 action 对象的函数 它存在的目的是消除相似 action 对象的重复定义 &#123; type: &quot;increment&quot;, payload: 1 &#125; &#123; type: &quot;increment&quot;, payload: 2 &#125; &#123; type: &quot;increment&quot;, payload: 3 &#125; const increment = (payload) =&gt; (&#123;type: &quot;increment&quot;, payload&#125;) 简要描述 reducer 函数的用法 reducer 就是一个函数, 在 Redux 中用于对状态进行更新, 是具体的写更新状态代码的地方. reducer 函数接收两个参数, 第一个参数是要管理的状态对象, 第二个参数是 action 对象 在 reducer 函数内部, 我们通常通过编写 switch case 对 action 类型进行匹配, 根据不同的 action 类型, 对状态进行不同的更新. 在状态更新完成之后, 必须要返回新的状态, 如果没有匹配到 action type, 默认就返回当前状态. 在 reducer 中不能做任何和修改状态无关的事情, 比如发送 ajax 请求, 开启定时器等 在 redux 中使用什么方法获取状态仓库中存储的状态对象 在 Redux 中获取状态仓库中存储的状态对象，可以使用 Redux 提供的 getState() 方法。getState() 方法是 Redux Store 对象中的一个函数，用于返回当前的状态树对象。 在 redux 中使用什么方法分发 action 对象 在 Redux 中分发 action 对象，可以使用 Redux 提供的 dispatch() 方法。dispatch() 方法是 Redux Store 对象中的一个函数，用于向 reducer 发送 action 对象，并触发 state 的更新。 react-redux 这个库的作用是什么? 解决 redux 状态更新组件不更新的问题 简要描述 react-redux 中提供的 connect 方法的作用及用法 react-redux 提供了 connect 方法让组件获取状态 connect 方法有两个参数都是函数, 第一个函数用于将 redux 状态映射到组件的 props 对象中 第二个函数用于将修改状态的逻辑映射到组件的 props 对象中 connect 方法在调用之后又返回一个函数, 通过调用该函数告诉 redux 状态及修改状态的逻辑要映射到哪一个组件中 connect 方法返回的方法在调用之后返回了一个被增强了的组件, 外部要渲染该组件 export default connect(mapStateToProps, mapDispatchToProps)(App) 为什么要将 action 对象中的 type 属性值定义为常量 20qz-pylcc 在 Redux 中，将 action 对象中的 type 属性值定义为常量，可以提高应用的可维护性和可重用性。 具体来说，将 action 类型定义为常量，可以避免由于手误或代码错误而导致的拼写错误，从而避免出现难以追踪的 bug。此外，常量还可以更好地传达代码中的含义，从而提高代码的可读性和可维护性。 另外，定义 action 类型为常量还可以增加代码的重用性。在 Redux 应用中，可能有多个 reducer 需要处理相同的 action 类型，如果将 action 类型定义为常量，可以将这些常量集中到一个文件中，然后在多个 reducer 中重复使用，从而减少重复的代码。 reducer 函数为什么要被分解再组合20qz-pylcc 在 Redux 应用中，reducer 函数被分解再组合可以提高应用的可维护性和可扩展性。 具体来说，将 reducer 函数分解成多个小的 reducer 函数，可以将不同部分的状态分开管理，从而使代码更加清晰和易于维护。 Redux 提供了 combineReducers() 函数，它可以将多个 reducer 函数合并成一个 reducer 函数，并生成一个新的状态树对象。这样，我们可以将不同部分的状态分开管理，并将它们组合成一个完整的状态树，从而使代码更加清晰、易于维护和可扩展。 如何理解 redux 中间件 redux 中间件允许开发者在修改状态的过程中加入一些中间环节, 在 reducer 函数中不能做的事情, 全部都要在中间件中去做 比如异步请求、定时器、控制台输出、DOM 操作、localStorage redux-thunk 中间件的作用是什么, 如何使用该中间件。 扩展了 dispatch 方法的功能, 使 dispatch 方法可以接收函数作为参数, 开发者可以将副作用代码写在该函数中, 比如异步请求, 其实就是让开发者在 redux 的工作流程中加入异步代码. npm install redux-thunk import thunk from &quot;redux-thunk&quot;; createStore(reducer, applyMiddleware(thunk)); dispatch(async (dispatch) =&gt; &#123; // 异步操作 dispatch(); &#125;) BrowserRouter 内部使用的是什么 API 实现的路由功能 在 React Router 库中，BrowserRouter 使用 HTML5 的 history API 实现了路由功能。 history API 是 HTML5 中引入的一组 API，用于在浏览器中操作浏览器的历史记录和地址栏。使用 history API，我们可以通过 JavaScript 修改 URL，同时还可以监听 URL 的变化，从而实现前端路由功能。 BrowserRouter 组件使用了 history API 中的 pushState() 和 replaceState() 方法，将 URL 中的路径与组件进行匹配，以确定要渲染的组件。当 URL 发生变化时，BrowserRouter 会通过 props 将新的 location 信息传递给子组件，从而触发重新渲染。 在 react-router-dom 路由库中使用什么组件配置路由规则, 使用的是什么属性 &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt; 使用哪些组件可以实现 a 链接跳转? 它们之间有什么区别 &lt;Link&gt;&lt;/Link&gt; &lt;NavLink&gt;&lt;/NavLink&gt; NavLink 链接被激活之后有高亮的类名 使用哪些方法可以实现编程式导航? 它们之间有什么区别 push 正常跳转, 记录会被添加到浏览器的历史记录中, 可以回退 replace 跳转, 但是跳转记录不会被添加到浏览器的历史记录中, 不可以回退 什么是查询参数？ 查询参数是指 URL 中的一部分，通常用于向服务器传递额外的信息。查询参数以 &quot;?&quot; 符号开始，后面是一系列键值对，多个键值对之间使用 &quot;&amp;&quot; 符号分隔。 https://www.example.com/search?q=react&amp;lang=en 如何传递查询参数 &lt;Link to=&quot;/detail?aid=1&quot;&gt;&lt;/Link&gt; 如何接收查询参数20qz-pylcc qs.parse(this.props.location.search, &#123;ignoreQueryPrefix: true&#125;) 如何实现路径参数的路由传参 1. 在路由规则中指定要进入到当前路由需要传递参数 &lt;Route path=&quot;/detail/:id&quot; /&gt; 2. 在链接中传递参数 &lt;Link to=&quot;/detail/1&quot;&gt;&lt;/Link&gt; 3. 接收参数 match.params Switch 组件的作用是什么 默认情况下, 路由规则是从上到下进行匹配的, 直到匹配完所有的路由规则, 匹配到哪些, 就渲染哪些路由规则对应的组件 Switch 组件可以指定在匹配到一个规则以后停止匹配 在路由规则中匹配请求路径时, 它的匹配方式模式有哪些? 精确匹配: 路由规则和请求路径完全吻合才能匹配成功, 要启用精确匹配, 需要 Route 组件的身上添加 exact 属性 模糊匹配(默认行为): 只要路由规则被请求路径所包裹即可匹配成功 /home =&gt; / 、 /home 在路由规则中如何定义 404 页面组件对应的路由规则. 路由规则从上到下依次进行匹配, 如果所有的路由规则都没有匹配成功, 就让它匹配最后一条 &lt;Route component=&#123;NotFound&#125;/&gt; 如何在普通组件中获取路由相关的信息. withRouter 路由守卫组件的作用是什么. 对路由组件进行的保护, 在进入组件之前, 判断你可以不以进入, 如果可以就让你进， 否则就不让你进. 路由组件懒加载有什么好处? 如何实现路由组件懒加载 提升首页加载速度. lazy Suspense 如何在 JSX 中通过组件的方式进行页面跳转. &lt;Redirect to=&quot;&quot;/&gt; React 中的 render()的用途是什么？ 在class组件中使用Render()，来返回在组件中显示的HTML。 它被用作读取props和state并将JSX代码返回到应用的根组件。 什么是 Props？ Props也被称作属性。它们将数据从一个组件传递到另一个组件（从父组件到子组件）。它们通常被用来呈现动态数据。 子组件永远不能将props发送到父组件，因为此流程是单向的（父到子）。 如何区分 State 和 Props State和props是具有不同功能的JavaScript对象。 props用于将数据从父组件传输到子组件，而state是对本地数据的存储，仅对当前组件可用，不能与其他组件共享。 useState 是什么？20qz-pylcc useState Hook是一个可以在函数组件中使用状态变量的存储。你可以把初始状态传给这个函数，它将返回一个包含当前状态值（不一定是初始状态）的变量和另一个更新这个值的函数。 useEffect 是什么？ useEffect Hook允许你在组件中执行副作用，例如数据获取、直接更新DOM、使用setTimeout()之类的计时器等等。 这个hook接受两个参数：回调函数和依赖项，它们允许您控制何时执行副作用。 注意：第二个参数是可选的。 useMemo() hook 的用途是什么？ useMemo() hook在函数组件中使用来记忆昂贵的函数，以便它们仅在设定的输入更改时调用，而不是每次渲染都调用。 它类似于useCallback hook，用于优化React函数组件的渲染行为。 React 的功能是什么？ 1.它使用虚拟DOM而不是真实DOM。 2.它使用服务器端渲染。 3.它遵循单向数据流或数据绑定。 列出 React 的一些主要优点。 它提高了应用程序的性能 它可以方便地在客户端和服务器端使用 由于有了JSX，代码的可读性提高了 React易于与其他框架（如Meteor，Angular等）集成 使用React，编写UI测试用例变得非常容易 对 Virtual DOM 有什么了解？解释它的工作。 虚拟DOM是轻量级的JavaScript对象，其最初只是真实DOM的副本。 它是一个节点树，列出了元素，它们的属性和内容作为对象及其属性。React的render函数从React组件中创建一个节点树。然后，它会响应由用户或系统执行的各种操作引起的数据模型中的突变来更新此树。 state 和 props 有何区别？ 定义位置不同：state 是在组件内部定义的，而 props 是从组件的父组件传递进来的。 可变性不同：state 是组件的内部状态，可以通过调用 setState() 方法来更新它的值，而 props 是从父组件传递进来的，通常是不可变的。 作用不同：state 用于存储组件的数据和状态，可以用来更新组件的视图。props 则用于从父组件向子组件传递数据和方法，用于子组件的渲染。 访问方式不同：在组件内部可以通过 this.state 来访问组件的 state 值，而在组件内部可以通过 this.props 来访问父组件传递给子组件的 props 值。 什么是高阶组件？ 高阶组件是重用组件逻辑的高级方法。基本上，这是从React的组成性质衍生的模式。HOC是自定义组件，在其中包裹了另一个组件。他们可以接受任何动态提供的子组件，但不会修改或复制其输入组件中的任何行为。您可以说HOC是“纯”组件。 Redux 遵循的三个原则是什么？ 1.单一事实来源：整个应用程序的状态存储在单个存储中的对象/状态树中。单一状态树使跟踪随时间变化以及调试或检查应用程序变得更加容易。 2.状态是只读的：更改状态的唯一方法是触发操作。动作是描述更改的普通JS对象。就像状态是数据的最小表示一样，操作是数据更改的最小表示。 3.使用纯函数进行更改： 为了指定操作如何转换状态树，您需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。 对 React refs 的理解？应用场景？ 在 React 中，Refs 是一种允许我们访问 DOM 节点或者组件实例的方法。Refs 提供了一种方式，允许我们直接操作 DOM 节点或组件实例，而无需经过 React 的 Virtual DOM。 Refs 的主要作用是解决访问组件内部 DOM 节点的问题。在 React 中，由于组件的渲染是通过 Virtual DOM 实现的，因此在某些情况下需要直接访问组件内部的 DOM 节点，比如进行动画效果、获取输入框的值等等。 应用场景： 获取组件内部的 DOM 节点，比如获取表单元素的值、滚动条的位置等。 与第三方库或原生 API 集成，比如集成 Google 地图、视频播放器等，需要访问 DOM 节点或组件实例。 控制组件的生命周期，比如手动触发组件的某些生命周期函数。 处理焦点、选择等问题，比如实现自动聚焦、选中文本等。 React-Router 的路由模式有哪些？ BrowserRouter：基于 HTML5 的 History API，使用 HTML5 中的 pushState() 和 replaceState() 方法来实现路由跳转。 HashRouter：使用 URL 中的哈希值来实现路由跳转，这是一种旧的路由实现方式。 MemoryRouter：使用内存中的 history 实现路由跳转，不会改变 URL。 StaticRouter：用于服务器端渲染，通过将 URL 作为 props 传递给组件来实现路由跳转。 NativeRouter：用于 React Native 开发，提供了与 React Native 导航 API 一致的路由实现方式。 React 中的 key 有什么作用？ 跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的Diff 因此key的值需要为每一个元素赋予一个确定的标识 设置 key 的注意事项有哪些？ key 应该是唯一的 key不要使用随机值（随机数在下一次 render 时，会重新生成一个数字） 避免使用 index 作为 key 什么是 HTTP? HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的协议。它是 Web 的基础，用于客户端和服务器之间的通信，客户端通过 HTTP 请求获取 Web 页面或资源，服务器通过 HTTP 响应返回 Web 页面或资源。 HTTP 通常使用 TCP（Transmission Control Protocol）作为传输协议，在传输层之上实现了一个面向请求和响应的客户端和服务器之间的通信。HTTP 请求由客户端发起，包含请求方法、URL、HTTP 版本号、请求头和请求正文等信息；HTTP 响应由服务器返回，包含响应状态码、响应头和响应正文等信息。 什么是 HTTPS？ HTTPS（Hypertext Transfer Protocol Secure）是基于 HTTP 协议的安全版本，它使用了 SSL/TLS 加密协议来保护数据传输的安全性和完整性。HTTPS 通过 SSL/TLS 协议对通信进行加密，可以防止数据在传输过程中被窃听和篡改。 HTTPS 的 URL 以 &quot;https://&quot; 开头，常用于传输敏感信息的 Web 应用，比如银行、电商等。 HTTP 和 HTTPS 的区别? 安全性：HTTP 不加密，数据传输容易被窃听和篡改；HTTPS 使用 SSL/TLS 加密协议，保证数据传输的安全性和完整性。 端口号：HTTP 默认使用端口号 80，HTTPS 默认使用端口号 443。 证书：HTTPS 需要使用 SSL/TLS 数字证书，用于验证服务器的身份和建立安全通道；而 HTTP 不需要证书。 性能：HTTPS 比 HTTP 的传输速度慢，因为 HTTPS 需要进行加密和解密操作，增加了服务器的负担和网络延迟。 SEO：HTTPS 可以提升网站的搜索引擎排名，因为谷歌等搜索引擎将 HTTPS 作为一个排名因素。 为什么说 HTTPS 比 HTTP 安全? HTTPS 比 HTTP 更安全，主要是因为 HTTPS 在数据传输的过程中使用了 SSL/TLS 协议来加密和验证数据的完整性，从而保证了数据的安全性和完整性。 HTTPS 是如何保证安全的？ 加密通信：HTTPS 使用 SSL/TLS 协议对通信过程进行加密，防止数据在传输过程中被窃听和篡改。SSL/TLS 协议通过使用公钥和私钥来建立安全通道，加密传输数据。 身份验证：HTTPS 使用 SSL/TLS 数字证书对服务器和客户端进行身份验证，防止中间人攻击。SSL/TLS 数字证书是由受信任的第三方机构颁发的，用于验证服务器的身份和建立安全通道。 数据完整性：HTTPS 使用消息摘要算法对传输的数据进行验证，保证数据的完整性，防止数据在传输过程中被篡改。消息摘要算法使用哈希函数将原始数据转换成固定长度的摘要值，然后将摘要值发送给接收方进行验证，如果验证失败，则说明数据已经被篡改。 如何理解 UDP 和 TCP? 区别? UDP（User Datagram Protocol）和 TCP（Transmission Control Protocol）都是用于在网络中传输数据的协议 连接性：TCP 是一种面向连接的协议，而 UDP 是一种无连接的协议。TCP 在传输数据之前需要先建立连接，而 UDP 不需要建立连接。 可靠性：TCP 是一种可靠的协议，它通过确认和重传机制来保证数据传输的可靠性。UDP 是一种不可靠的协议，它不提供数据重传机制。 消息大小限制：TCP 没有消息大小的限制，而 UDP 的消息大小被限制在 65,507 个字节以内。 传输效率：由于 TCP 需要建立连接、确认和重传数据等机制，因此其传输效率相对较低。而 UDP 没有这些机制，因此其传输效率相对较高。 DNS 协议 是什么？ DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器 说说 DNS 完整的查询过程? 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表 若没有命中，则继续搜索操作系统的 DNS 缓存 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起 说说地址栏输入 URL 敲下回车后发生了什么？ URL解析 DNS 查询 TCP 连接 HTTP 请求 响应请求 页面渲染 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?20qz-pylcc HTTP1.0： 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接 HTTP1.1： 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用 在同一个TCP连接里面，客户端可以同时发送多个请求 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着 新增了一些请求方法 新增了一些请求头和响应头 HTTP2.0： 采用二进制格式而非文本格式 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行 使用报头压缩，降低开销 服务器推送 说说 HTTP 常见的状态码有哪些，适用场景？ 1 表示消息 2 表示成功 3 表示重定向 4 表示请求错误 5 表示服务器错误 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输 206：一般用来做断点续传，或者是视频文件等大文件的加载 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分 400：参数有误，请求无法被服务器识别 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时 503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503 504：网关超时 说一下 GET 和 POST 的区别？ GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中 常用的版本管理工具有哪些？ git SVN 谈谈你对 git 的理解。 git是一个分布式版本控制软件，最初目的是为更好地管理Linux内核开发而设计 git 常见的命令 git add git commit git push git pull git clone git checkout 说说 Git 中 fork, clone,branch 这三个概念，有什么区别? fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作” clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓 branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支 说说对 git pull 和 git fetch 的理解？有什么区别？ git fetch 命令用于从另一个存储库下载对象和引用 git pull 命令用于从另一个存储库或本地分支获取并集成(整合) 相同点： 在作用上他们的功能是大致相同的，都是起到了更新代码的作用 不同点： git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge 相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并 如何解决 git 冲突？ 当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交 说说 git 发生冲突的场景？ 一般情况下，出现分支的场景有如下： 多个分支代码合并到一个分支时 多个分支向同一个远端分支推送 git reset 干什么的？ reset用于回退版本，可以遗弃不再使用的提交 执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容 git revert 是干什么的？ 跟git reset用法基本一致，git revert 撤销某次操作，此次操作之前和之后的 commit和history都会保留，并且把这次撤销，作为一次最新的提交 get reset 和 git revert 的区别20qz-pylcc git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容 在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别 当你开发到一半，现在要修改别的分支问题的时候，怎么处理？ 可以使用git stash缓存当前区域的代码 git stash：保存开发到一半的代码 git commit -m &#39;修改问题&#39; git stash pop：将代码追加到最新的提交之后","categories":[],"tags":[]},{"title":"重点掌握面试题","slug":"重点掌握面试题","date":"2023-06-01T02:40:22.969Z","updated":"2023-06-01T02:49:48.778Z","comments":true,"path":"2023/06/01/重点掌握面试题/","link":"","permalink":"https://eathl.github.io/2023/06/01/%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"001：1、react 有哪些性能优化的点 1、https://github.com/brickspert/blog/issues/36 2、v8 垃圾回收机制 https://juejin.cn/post/6844904016325902344 3、CSS 样式隔离手段 https://juejin.cn/post/6844904034281734151#heading-9 4、行内元素、块级元素有哪些，区别是什么 什么叫行内元素？ 常见的span、a、lable、strong、b等html标签都是行内元素 什么叫块级元素？ 常见的div、p、li、h1、h2、h3、h4等html标签都是块级元素 行内元素属性: 行内元素属性标签它和其它标签处在同一行内 行内元素属性标签无法设置宽度，高度 距顶部距离 距底部距离 行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的 行内元素属性标签内部不能嵌套行属性标签（a链接内不能嵌套其他链接） 块级元素属性: 每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始） 块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离 块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的100% 块级元素属性标签是可以直接嵌套的 p标签中不能嵌套div标签 5、聊下你知道的浏览器架构 浏览器进程（Browser process） 浏览器进程负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。 渲染进程（Renderer process） 渲染进程负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理等。 插件进程（Plugin process） 插件进程负责为浏览器提供各种额外的插件功能，例如 flash。 GPU 进程（GPU process） GPU 进程负责提供成像的功能。 当然还有其他像扩展进程或工具进程等其他进程，可以在 Chrome 的 Task Manager 面板中查看，面板中列出了运行的进程和其占用的 CPU、内存情况。 https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3 6、是否有写过 webpack 插件 看下webpack.config.js 如果没有运行 yarn eject 就会解包处理config文件夹，文件夹中包含。 https://juejin.cn/post/6844903789804126222 7、websocket 建立过程 https://blog.csdn.net/LL845876425/article/details/106393358 8、合并二维有序数组成一维有序数组 arr.reduce((m,n)=&gt;m.concat(n)) arr.flat() [].concat.apply([],arr) 9、实现防抖函数 E: const debounce = (func, wait) =&gt; &#123; let timer return () =&gt; &#123; clearTimeout(timer) timer = setTimeout(func, wait); &#125; &#125; D: function debounce(callback,delay)&#123; let timer=null; var that=this; return function()&#123; var args=Array.prototype.slice.call(arguments); if(timer !== null)&#123; clearTimeout(timer) &#125; timer=setTimeout(()=&gt;&#123; callback.apply(that,args) &#125;,delay) &#125; &#125; 10、Vue 首屏白屏或者加载慢如何解决 https://juejin.cn/post/6995455015972241444 11、Vue 线上环境和开发环境如何切换 .env文件或者env,js文件，再通过process.env判断切换 12、谈谈 axios 拦截器 请求拦截器和响应拦截器; 请求拦截器; axios.interceptors.request.use(func); 响应拦截器; axios.interceptors.response.use(func); 13、hash 和 history 路由的区别 https://blog.csdn.net/Charissa2017/article/details/104779412 14、call，apply 和 bind 的作用和区别？ call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。 他们俩之间的差别在于参数的区别，call和apply的第一个参数都是要改变上下文的对象， 而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。 1、判断变量类型： &lt;script&gt; let arr1 = [1, 2, 3]; let str1 = &#39;string&#39;; let obj1 = &#123; name: &#39;thomas&#39; &#125;; function isArray(obj) &#123; return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;; &#125; console.log(fn1(arr1)); // true // 判断类型的方式，这个最常用语判断array和object，null(因为typeof null等于object) console.log(Object.prototype.toString.call(arr1)); // [object Array] console.log(Object.prototype.toString.call(str1)); // [object String] console.log(Object.prototype.toString.call(obj1)); // [object Object] console.log(Object.prototype.toString.call(null)); // [object Null] &lt;/script&gt; 2、利用call和apply做继承 function Animal(name)&#123; this.name = name; this.showName = function()&#123; console.log(this.name); &#125; &#125; function Cat(name)&#123; Animal.call(this, name); &#125; // Animal.call(this) 的意思就是使用this对象代替Animal对象，那么 // Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了 var cat = new Cat(&quot;TONY&quot;); cat.showName(); //TONY 参考给大家发的有道文档 15、useMemo 的作用 数据缓存机制，避免在每次渲染时都进行高开销的计算。 https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo 16、react 中发送请求一般在哪个 hook 中 useEffect 17、如何更新组件的状态 render setState(class component) forceUpdate(class component) useState (function component) 18、如何监听 react 状态更新 componentWillUpdate useEffect 19、Vue 中的响应式原理 Vue不支持IE8以下版本的浏览器，因为Vue是基于 Object.defineProperty 来实现数据响应的，而Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据； 受现代JavaScript 的限制 (以及废弃 Object.observe)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让Vue转换它，这样才能让它是响应的。 shim:shim可以将新的API引入到旧的环境中，而且仅靠就环境中已有的手段实现。意思就是Object.defineProperty这个特性是无法使用低级浏览器中的方法来实现的，所以Vue不支持IE8以及更低版本的浏览器。 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图。 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 20、Vue-Router 有哪几种路由守卫? 全局守卫 router.beforeEach 全局前置守卫 router.beforeResolve 全局解析守卫 router.afterEach 全局后置钩子 路由独享守卫 beforeEnter 路由组件内的守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 21、简述 Vuex 的数据传递流程 1、通过new Vuex.Store()创建一个仓库 state是公共的状态，state---&gt;components渲染页面 2、在组件内部通过this.$store.state.属性 来调用公共状态中的state，进行页面的渲染。 3、当组件需要修改数据的时候，必须遵循单向数据流。通过this.$store.dispatch来触发actions中的方法 4、actions中的每个方法都会接受一个对象 这个对象里面有一个commit方法，用来触发mutations里面的方法 5、mutations里面的方法用来修改state中的数据 mutations里面的方法都会接收到2个参数 一个是store中的state另外一个是需要传递到参数 6、当mutations中的方法执行完毕后state会发生改变，因为vuex的数据是响应式的 所以组件的状态也会发生改变 22、Vue 和 jQuery 两者之间的区别是什么 jquery直接操作dom Vue不直接操作dom，采用虚拟dom Vue通过数据驱动界面 jquery通过选择器选取元素，进行取值赋值、事件绑定等操作 Vue对项目的侵入较强。 23、Object.defineProperty 和 Proxy 的区别 1）Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has等等是Object.defineProperty 不具备的； Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的 新标准的性能红利； 2）Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill。 24、Vue 怎么在组件中监听路由参数的变化？ 第一种 watch: &#123; &#39;$route&#39;(to, from) &#123; // 在此处监听 &#125;, &#125;, 第二种beforeRouteUpdate (to, from, next) &#123; //这里监听 &#125;, 25、watch、methods 和 computed 的区别? 1．computed：计算属性将被混入到Vue实例中。所有getter和setter的this上下文自动地绑定为Vue实例。 2．methods： methods将被混入到Vue实例中。可以直接通过VM实例访问这些方法，或者在指令表达式中使用。方法中的this自动绑定为Vue实例。 3．watch： 观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式， 值是对应回调函数。值也可以是方法名，或者包含选项的对象，Vue 实例将会在 实例化时调用 $watch()，遍历 watch 对象的每一个属性。 2）三者的加载顺序 1. computed 是在 HTML DOM 加载后马上执行的，如赋值；（属性将被混入 到 Vue 实例） 2. methods 则必须要有一定的触发条件才能执行，如点击事件 3. watch 呢？它用于观察 Vue 实例上的数据变动。 3）默认加载的时候 先 computed 再 watch，不执行 methods； 4）触发某一事件后 先 computed 再 methods 再到 watch computed 属性 vs method 方法 computed 计算属性是基于它们的依赖进行缓存的。 5）总结计算属性computed只有在它的相关依赖发生改变时才会重新求值，当有一个性能开销比较大的的计算属性A，它需要遍历一个极大的数组和做大量的计算，然后我们可能有其他的计算属性依赖于A，这时候，我们就需要缓存，每次确实需要重新加载，不需要缓存时用 methods 26、Vue 循环 key 的作用 key 的作用主要是为了高效的更新虚拟 DOM。 27、对比 Vue 和 React 的差异。 相同点： 数据驱动视图 组件化 都使用 Virtual DOM 不同点： 核心思想不同：React：React推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助onChange和setState来实现。Vue：灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确 组件写法不同：react：JSX + inline style vue：template diff算法不同 响应式原理不同： Vue依赖收集，自动优化，数据可变。 Vue递归监听data的所有属性,直接修改。 当数据改变时，自动找到引用组件重新渲染。 React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制 28、ES 中 JavaScript 的数据类型有哪些？ Boolean，null，undefined,Number,BigInt,String,Symbol,Object 29、在 JavaScript 中，可以通过哪些方式改变 this 指向。 回答这个首先明确下this的指向问题： 一般来说，在this指向全局对象window（函数），对象里是指向调用对象，构造函数指向，指向实例，事件指向触发的dom对象，箭头函数没有自己的this，指向外层的代码的this，在严格模式下，this为undefined。 改变this指向可以使用call、apply、bind等方法，具体见题14 30、http 常见的 header。 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text&#x2F;plain, text&#x2F;html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的 web 服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP 授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D; Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1 默认进行持久连接） Connection: close Cookie HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器。 Cookie: $Version&#x3D;1; Skin&#x3D;new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的 MIME 信息 Content-Type: application&#x2F;x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的 Email From: &#117;&#115;&#101;&#x72;&#64;&#101;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109; Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D; Range 只请求实体的一部分，指定范围 Range: bytes&#x3D;500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q&#x3D;0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11 User-Agent User-Agent 的内容包含发出请求的用户信息 User-Agent: Mozilla&#x2F;5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 31、http 中 cache-control 的含义 Cache-Control 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。 详见：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control 32、JavaScript 的对象类型包含。 数组，函数，正则，日期 33、判断一个变量是值是数组还是对象。 var a = []; // 1.基于instanceof a instanceof Array; // 2.基于constructor a.constructor === Array; // 3.基于Object.prototype.isPrototypeOf Array.prototype.isPrototypeOf(a); // 4.基于getPrototypeOf Object.getPrototypeOf(a) === Array.prototype; // 5.基于Object.prototype.toString Object.prototype.toString.apply(a) === &quot;[object Array]&quot;; //Array.isArray 的polyfill if (!Array.isArray) &#123; Array.isArray = function (arg) &#123; return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;; &#125;; &#125; 34、类数组对象 arguments。 arguments 是一个对应于传递给函数的参数的类数组对象。arguments对象是所有（非箭头）函数中都可用的局部变量。 35、[“1”,”2”,”3”].map(parseInt) // parseInt(string, radix) -&gt; map(parseInt(value, index)) /* first iteration (index is 0): */ parseInt(&quot;1&quot;, 0); // 1 /* second iteration (index is 1): */ parseInt(&quot;2&quot;, 1); // NaN /* third iteration (index is 2): */ parseInt(&quot;3&quot;, 2); // NaN 如果radix未指定，且第一个参数为string，radix默认会10。如果radix的小于2或者大于36，返回结果也是NaN。 参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt 36、JS 模块化规范有哪些？ commomJS,AMD.CMD,ES6模块化，...... 37、Array.from 的用法。 Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。console.log(Array.from(&#39;foo&#39;));=&gt;[&quot;f&quot;,&quot;o&quot;,&quot;o&quot;] 38、Vue 开发环境和线上环境如何切换 process.env; 39、Object.defineProperty 和 Proxy 的区别 参考23题; 40、React 怎么在组件中监听路由参数的变化。 在useEffect()中可以通过history监听路由变化 const history = useHistory() useEffect(()=&gt;&#123; history.listen(historyLocation=&gt;....) &#125;) class component props.history 41、对比 Vue 和 React 的差异。 27题 42、React 项目优化的方式有哪些。 减少dom更新次数 使用生产版本 长列表优化 webpack压缩（rollup） 缓存 https://zh-hans.reactjs.org/docs/optimizing-performance.html 43、Hash 和 history 路由模式的区别？ hash模式：监听浏览器地址hash值变化，执行相应的js切换网页； history模式：利用history API实现url地址改变，网页内容改变； hash模式：使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。 history模式：window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。 每当 history 对象出现变化时，就会触发 popstate 事件。 hash 就是指 url 尾巴后的 # 号以及后面的字符，history没有底带#，外观上比hash 模好看些hash回车刷新会加载到地址栏对应的页面，history一般就是404掉了hash 能兼容到IE8， history 只能兼容到 IE10； 44、call，apply 和 bind 的作用和区别 14题 45、谈谈 axios 拦截器。 请求拦截器和响应拦截器; 请求拦截器; axios.interceptors.request.use(func); 响应拦截器; axios.interceptors.response.use(func); 46、谈谈浏览器缓存，如何进行强制缓存？ 浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中.缓存分为： 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程. 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程 控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 47、React 如何更改组件的状态，如何去监听组件状态？ useEffect(); 48、实现一个算法，生成一个不会重复的 uuid。 Date.now().toString(16); md5(Date.now()); sha1; 49、定义一个方法，实现数组的扁平化 核心代码 1、arr.flat(Infinity) 2、function flatten(arr) &#123; return arr.reduce((res,next) =&gt;&#123; return res.concat(Array.isArray(next)? flatten(next) : next); &#125;,[]); &#125; 3、arr.toString().split(&quot;,&quot;) 50、定义一个方法，实现数组的排序 function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; var middle = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = middle; &#125; &#125; &#125; return arr; &#125; 51、实现浅拷贝的几种方式。 1、Object.assign(target,source) 2、扩展运算符 let cloneObj = &#123; ...obj &#125; 3、concat() let arr = [1,3,4,6,8]; let copyArr = arr.concat(); console.log(copyArr) 4、slice() 52、手写一个浅拷贝。 const shallowClone = (target) =&gt; &#123; if (target === &quot;object&quot; &amp;&amp; target !== null) &#123; const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; for (prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; cloneTarget[prop] = target[prop]; &#125; &#125; return cloneTarget; &#125; return target; &#125;; let arr = [1, 3, 5, 7, &#123; name: &quot;apple&quot; &#125;]; let newArr = shallowClone(arr); console.log(newArr); 53、new 的执行过程。 function Car()&#123; this.name = &quot;MAN&quot; &#125; var obj = new Car() console.log(obj.name) //MAN 大致的执行步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（this 指向新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。 54、new 的实现 function _new(type) &#123; debugger; if (typeof type !== &quot;function&quot;) &#123; throw &quot;type must be function&quot;; &#125; var args = Array.prototype.slice.call(arguments, 1); let obj = new Object(); //链接空对象到原型上 obj.__proto__ = Object.create(type.prototype); //绑定obj的this上下文 let res = type.apply(obj, args); let isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null; let isFunction = typeof res === &quot;function&quot;; return isObject || isFunction ? res : obj; &#125; function Car(name, color) &#123; this.name = name; this.color = color; Car.prototype.getName = function () &#123; return this.name; &#125;; &#125; let obj11 = _new(Car, &quot;MAN&quot;, [&quot;red&quot;, &quot;blue&quot;]); console.log(obj11); 55、什么是闭包？ 闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。 因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。 &#39;闭包产生的本质就是：当前环境中存在指向父级作用域的引用。&#39; 56、闭包的表现形式。 1. 返回一个函数，上面讲原因的时候已经说过，这里就不赘述了。 2. 在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。 3. 作为函数参数传递的形式 4. IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域 57、循环引用问题。 for(var i = 1; i &lt;= 5; i ++)&#123; setTimeout(function() &#123; console.log(i) &#125;, 0) console.log(i); &#125; 以上输出的结果是？ 上图的输出结果并不是想象中的 1、2、3、4、5。而是6，为什么呢？原因如下： 1、setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。 2、因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。 &#39;解决办法：&#39; 1、最简单的使用es6的let。 for(let i = 1; i &lt;= 5; i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0) &#125; 2、利用IIFE 立即执行函数。 for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;, 0) &#125;)(i) &#125; 3、利用定时器传入第三个参数。 for(var i=1;i&lt;=5;i++)&#123; setTimeout(function(j) &#123; console.log(j) &#125;, 0, i) &#125; 58、JavaScript 中改变自身的数组方法。 pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。 59、JavaScript 中不改变自身的数组方法。 concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf以及 ES7 新增的方法 includes。 60、简述 promise，promise 有哪些状态？.then 返回的是什么？promise.race,promise.any,promise.all 分别代表什么意思？ 1、 Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。 2、 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）: 意味着操作成功完成。 已拒绝（rejected）: 意味着操作失败。 3、 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。 4、 Promise.race(iterable) 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.any(iterable) 接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值 Promise.all(iterable) 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，","categories":[],"tags":[]},{"title":"前端面试必问基础","slug":"前端面试必问基础","date":"2023-06-01T02:40:17.375Z","updated":"2023-06-01T02:48:06.912Z","comments":true,"path":"2023/06/01/前端面试必问基础/","link":"","permalink":"https://eathl.github.io/2023/06/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1、H5 的新特性有哪些？C3 的新特性有哪些？H5 新特性 1、拖拽释放(Drap and drop) API ondrop 拖放是一种常见的特性，即抓取对象以后拖到另一个位置 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放 2、自定义属性 data-id 3、语义化更好的内容标签(header,nav,footer ,aside, article, section) 4、音频 ,视频(audio, video) 如果浏览器不支持自动播放怎么办? 在属性中添加 autoplay(谷歌浏览器不支持音频自动播放，但是视频支持静音自动播放) 5、画布 Canvas 5.1）getContext() 方法返回一个用于在画布上绘图的环境 Canvas.getContext(contextID) 参 数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是 “2d”，它指定了二 维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图 API 5.2）cxt.stroke() 绘制线条 5.3）canvas 和 image 在处理图片的时候有什么区别? image 是通过对象的形式描述图片的,canvas 通过专门的 API 将图片绘制在画布上. 6、 地理(Geolocation) API 其实 Geolocation 就是用来获取到当前设备的经纬度（位置） 7、 本地离线存储 localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间， 直到手动去删除 8、 sessionStorage 该数据对象临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页 之后将会删除这些数据。 9、 表单控件 calendar , date , time , email , url , search , tel , file , number 10、新的技术 webworker, websocket , Geolocation CSS3 新特性 1、颜色: 新增 RGBA , HSLA 模式 2、文字阴影(text-shadow) 3、边框: 圆角(border-radius) 边框阴影 : box-shadow 4、盒子模型: box-sizing 5、背景:background-size background-origin background-clip 6、渐变: linear-gradient , radial-gradient 7、过渡 : transition 可实现属性的渐变 8、自定义动画 animate @keyfrom 9、媒体查询 多栏布局 @media screen and (width:800px) {…} 10、border-image 图片边框 11、2D 转换&#x2F;3D 转换;transform: translate(x,y) rotate(x,y) skew(x,y) scale(x,y) 12、字体图标 iconfont&#x2F;icomoon 13、弹性布局 flex 2、如何使一个盒子水平垂直居中？方法一：利用定位 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; position: absolute; background-color: red; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt;&lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 方法二：利用 margin:auto; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;/head&gt; &lt;/html&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; position: absolute; background-color: aqua; margin: auto; top: 0; left: 0; right: 0; bottom: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 方法三：利用 display：flex;设置垂直水平都居中 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; display: flex; justify-content: center; align-items: center; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 方法四：利用 transform &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3、CSS 的盒模型？盒子模型（Box Modle）可以用来对元素进行布局，包括内边距，边框，外边距，和实际 内容这几个部分。 盒子模型分为两种: 第一种是 W3C 标准的盒子模型（标准盒模型） 第二种 IE 标准的盒子模型（怪异盒模型） 标准盒模型与怪异盒模型的表现效果的区别之处： 1、标准盒模型中 width 指的是内容区域 content 的宽度 height 指的是内容区域 content 的高度 标准盒模型下盒子的大小 &#x3D; content + border + padding + margin 2、怪异盒模型中的 width 指的是内容、边框、内边距总的宽度（content + border + padding）；height 指的是内容、边框、内边距总的高度 。 怪异盒模型下盒子的大小&#x3D;width（content + border + padding） + margin 4、CSS 单位中 px、em 和 rem 的区别？1、px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位。 2、em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺 寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小因此并不是一 个固定的值。 3、rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。 5、为什么会出现浮动？浮动元素会引起什么问题？如何清除浮动？浮动将元素排除在普通流之外，即元素将脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留 。 为什么需要清除浮动 1、子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素； 2、与浮动元素同级的非浮动元素（内联元素）会跟随其后； 3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解 决方法 清除浮动的方式 1、使用 CSS 中的 clear:both（; 放一个空的标签，并设置上述 css，注意该标签必须是块元素）, 属性来清除元素的浮动 可解决 2、3 问题 2、对于问题 1，添加如下样式，给父元素添加 clearfix 样式： .clearfix:after &#123; content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; /* for IE */ .clearfix &#123; *zoom: 1; &#125; 3、给父级元素设置双伪元素； .clearfix:after &#123; content: &quot;&quot;; /*设置内容为空*/ height: 0; /*高度为 0*/ line-height: 0; /*行高为 0*/ display: block; /*将文本转为块级元素*/ visibility: hidden; /*将元素隐藏*/ clear: both; /*清除浮动*/ &#125; .clearfix &#123; zoom: 1; /*为了兼容 IE*/ &#125; 4、给父级元素设置 overflow：hidden；或 overflow：auto；本质是构建一个 BFC。 5、如何解决 margin“塌陷”？外边距塌陷共有两种情况： 第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给 margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况 的方法为：两个外边距不同时出现 第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。 解决方案： 1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成透 明：border：1px solid transparent）； 2、为父盒子添加 overflow：hidden； 3、为父盒子设定 padding 值； 4、为父盒子添加 position：fixed； 5、为父盒子添加 display：table； 6、利用伪元素给父元素的前面添加一个空元素 .father::before &#123; content: &quot;&quot;; display: table; &#125; 6、BFC 是什么？定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干 布局规则 1、内部的 Box 会在垂直方向，一个接一个地放置。 2、Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。 3、每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 4、BFC 的区域不会与 float box 重叠 5、BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 。 6、计算 BFC 的高度时，浮动元素也参与计算。 哪些元素会生成 BFC： 1、根元素 2、float 属性不为 none 3、position 为 absolute 或 fixed 4、display 为 inline-block， table-cell， table-caption， flex， inline-flex 5、overflow 不为 visible 7、JavaScript 数据类型。基本类型：Number、String、Boolean、null、undefined，symbol。 引用类型：Object 8、数据类型的检测。常用的数据类型检测有三种方式。 1、typeof 2、instanceof 3、Object.prototype.toString.call(&#123;&#125;) // 同上结果，加上call也ok //通用方法 检测类型 function getType(obj)&#123; let type = typeof obj; if (type !== &quot;object&quot;) &#123; // 先进行typeof判断，如果是基础数据类型，直接返回 return type; &#125; // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, &#39;$1&#39;); // 注意正则中间有个空格 &#125; 9、实现浅拷贝的几种方法1、Object.assign(target,source) 2、扩展运算符 let cloneObj = &#123; ...obj &#125; 3、concat() let arr = [1,3,4,6,8]; let copyArr = arr.concat(); console.log(copyArr) 4、slice() 10、手写一个浅拷贝const shallowClone = (target) =&gt; &#123; if (target === &quot;object&quot; &amp;&amp; target !== null) &#123; const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; for (prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; cloneTarget[prop] = target[prop]; &#125; &#125; return cloneTarget; &#125; return target; &#125;; let arr = [1, 3, 5, 7, &#123; name: &quot;apple&quot; &#125;]; let newArr = shallowClone(arr); console.log(newArr); 11、null，undefined 的区别区别 null 表示一个对象被定义了，值为“空值”； undefined 表示不存在这个值 typeof undefined &#x2F;&#x2F;“undefined” undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于 undefined typeof null &#x2F;&#x2F;“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证 null 时，一定要使用&#x3D;&#x3D;&#x3D; ，因为 &#x3D;&#x3D; 无法分别 null 和 undefined undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 典型用法是： 1、变量被声明了，但没有赋值时，就等于 undefined 2、调用函数时，应该提供的参数没有提供，该参数等于 undefined 3、对象没有赋值的属性，该属性的值为 undefined 4、函数没有返回值时，默认返回 undefined null 表示”没有对象”，即该处不应该有值。典型用法是： 4.1） 作为函数的参数，表示该函数的参数不是对象 4.2） 作为对象原型链的终点 12、如何区分数组和对象？方法一：通过 ES6 中的 Array.isArray 来识别 Array.isArray([]); //true Array.isArray(&#123;&#125;); //false 方法二：通过 instanceof 来识别 [] instanceof Array //true &#123;&#125; instanceof Array //false 方法三：通过调用 constructor 来识别 &#123;&#125;.constructor //返回 object [].constructor //返回 Array 方法四：通过 Object.prototype.toString.call 方法来识别 Object.prototype.toString.call([]); //[&quot;object Array&quot;] Object.prototype.toString.call(&#123;&#125;); //[&quot;object Object&quot;] 13、多维数组降维的几种方法（1）数组字符串化 let arr = [ [222, 333, 444], [55, 66, 77], ]; arr += &quot;&quot;; arr = arr.split(&quot;,&quot;); (2) Array .prototype .flat() var arr1 = [1, 2, [3, 4]]; arr1.flat(); // [1, 2, 3, 4] var arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); // [1, 2, 3, 4, [5, 6]] var arr3 = [1, 2, [3, 4, [5, 6]]]; arr3.flat(2); // [1, 2, 3, 4, 5, 6] //使用 Infinity 作为深度，展开任意深度的嵌套数组 arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6] (3) 使用 reduce、concat 和递归无限反嵌套多层嵌套的数组 var arr1 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]]; function flattenDeep(arr1) &#123; return arr1.reduce( (acc, val) =&gt; Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), [] ); &#125; flattenDeep(arr1); // [1, 2, 3, 1, 2, 3, 4, 2, 3, 4] (4) 递归 function reduceDimension(arr) &#123; let ret = []; let toArr = function (arr) &#123; arr.forEach(function (item) &#123; item instanceof Array ? toArr(item) : ret.push(item); &#125;); &#125;; toArr(arr); return ret; &#125; 14、JavaScript 中的作用域、预解析与变量声明提升？作用域 就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域 1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是 可以访问的； 2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无 法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量 3、块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域 块级作用域 函数作用域 词法作用域之间的区别： 3.1）块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域 3.2）词法作用域描述的是，变量的查找规则 之间的关系： 1、 块级作用域 包含 函数作用域 2、 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描 述了作用域的规则 ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词 法作用域 预解析 JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器执行 JavaScript 代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值 2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用 3.先提升 function，在提升 var 变量提升 变量提升：定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。 函数提升：JavaScript 解析器首先会把当前作用域的函数声明提前到整个作用域的最前面。 15、如何实现数组的随机排序var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; function randSort1(arr) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; var rand = parseInt(Math.random() * len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr; &#125; console.log(randSort1(arr)); 16、继承的几种方式。1、原型链继承 prototypeChainInheritance 缺点：内存共享，一个发生改变，另一个也会发生改变 function Car()&#123; this.name =&#39;Volvo&#39;, this.color = [&#39;white&#39;,&#39;black&#39;,&#39;red&#39;] &#125; function Truck()&#123; this.price = 20000 &#125; Truck.prototype = new Car() const obj = new Truck(); const obj1 = new Truck(); obj.price = 30000; console.log(obj) console.log(obj1) 2、构造函数继承 constructorInheritance 缺点：父类的引用属性，不会被共享 function Car()&#123; this.name = &quot;MAN&quot; &#125; Car.prototype.getName = function()&#123; return this.name &#125; function Truck()&#123; Car.call(this) this.price = 30000 &#125; let obj = new Truck() console.log(obj) console.log(Truck.getName()) 3、组合继承 combinatorial inheritance function Car()&#123; this.name = &quot;MAN&quot; this.color = [&#39;red&#39;,&#39;white&#39;,&#39;blue&#39;] &#125; Car.prototype.getName = function () &#123; return this.name &#125; function Truck()&#123; Car.call(this) this.price = 6666 &#125; Truck.prototype = new Car() Truck.prototype.constructor = Truck var obj1 = new Truck() var obj2 = new Truck() obj1.color.push(&#39;black&#39;) console.log(obj1.color) console.log(obj2.color) console.log(obj1.getName()) console.log(obj2.getName()) 4、原型式继承 prototypal Inheritance 缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能 let car = &#123; name: &#39;MAN&#39;, color: [&#39;red&#39;,&#39;gold&#39;,&#39;white&#39;], getName: function ()&#123; return this.name &#125; &#125; let truck = Object.create(car) truck.name = &#39;Volvo&#39;; truck.color.push(&#39;black&#39;) let lorn = Object.create(truck) lorn.color.push(&#39;blue&#39;) console.log(truck.name === truck.getName()) console.log(truck.getName()) console.log(lorn.color) console.log(car.getName()) 5、寄生式继承 let car = &#123; name: &#39;MAN&#39;, color: [&#39;red&#39;,&#39;gold&#39;,&#39;white&#39;], getName: function ()&#123; return this.name &#125; &#125; function clone(original) &#123; let clone = Object.create(original); clone.getColor = function() &#123; return this.color; &#125;; return clone; &#125; let obj = clone(car); console.log(obj.getName()); console.log(obj.getColor()); 6、寄生组合继承 function clone(parent,child)&#123; // 解决构造继承中多进行一次构造的过程 child.prototype = Object.create(parent.prototype) child.prototype.constructor = child &#125; function Car()&#123; this.name = &quot;MAN&quot; this.color = [&#39;red&#39;,&#39;white&#39;,&#39;black&#39;] &#125; Car.prototype.getName = function()&#123; return this.name &#125; function Truck()&#123; Car.call(this) this.voice = &#39;wuwuwuuw^&#39; &#125; clone(Car,Truck) Truck.prototype.getVoice = function()&#123; return this.voice &#125; let obj = new Truck() console.log(obj) console.log(obj.getName()) console.log(obj.getVoice()) 7、ES6的extends继承 class Car &#123; constructor(name) &#123; this.name = name; &#125; getName = function()&#123; console.log(&quot;Car:&quot;,this.name) &#125; &#125; class Truck extends Car&#123; constructor(name,price)&#123; super(name) this.price = price &#125; &#125; const obj = new Truck(&#39;MAN&#39;,333333) obj.getName() 17、apply &amp; call &amp; bind 的介绍都可以改变函数 func 的 this 指向。 call 和 apply 的区别在于，传参的写法不同：apply 的第 2 个参数为数组； call 则是从第 2 个至第 N 个都是给 func 的传参； 而 bind 和这两个（call、apply）又不同，bind 虽然改变了 func 的 this 指向，但不是马上执行， 而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。 18、闭包的概念闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。 因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。 &#39;闭包产生的本质就是：当前环境中存在指向父级作用域的引用。&#39; 19、如何解决循环引用问题。for(var i = 1; i &lt;= 5; i ++)&#123; setTimeout(function() &#123; console.log(i) &#125;, 0) &#125; 上图的输出结果并不是想象中的 1、2、3、4、5。而是6，为什么呢？原因如下： 1、setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。 2、因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。 &#39;解决办法：&#39; 1、最简单的使用es6的let。 for(let i = 1; i &lt;= 5; i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0) &#125; 2、利用IIFE 立即执行函数。 for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;, 0) &#125;)(i) &#125; 3、利用定时器传入第三个参数。 for(var i=1;i&lt;=5;i++)&#123; setTimeout(function(j) &#123; console.log(j) &#125;, 0, i) &#125; 20、dom 节点的 Attribute 和 Property 有何区别？1、什么是 Property 每 个 DOM 节点都是一个 object 对象，有自己的 property 和 method 。 原 则 上 property 应 该 仅 供 js 操 作 ， 不 会 出 现 在 html 中 （ 默 认 属 性 除 外 ：id&#x2F;src&#x2F;href&#x2F;className&#x2F;dir&#x2F;title&#x2F;lang 等），和其他 js object 一样，自定义的 property 也会出现在 object 的 for…in 遍历中 2、什么是 Attribute attribute 出现 在 dom 中，js 提供了 getAttribute&#x2F;setAttribute 等方法来获取和改变它的值，最后作用于 html 中，可以影响 innerHTML 获取的值。可以通过访问 dom 节点的 attributes 属性来获取改节点的所有的 attribute。（在 IE&lt;9 中,attribute 获取和改变的实际上是 property。） 3、两者之间的区别是 3.1）自定义的 Property 与 Attribute 不同步,不相等 3.2）非自定义的 DOM property 与 attributes 是有条件同步的 3.3）非自定义的属性(id&#x2F;src&#x2F;href&#x2F;name&#x2F;value 等)，通过 setAttribute 修改其特性值可以同步 作用到 property 上，而通过.property 修改属性值有的(value)时候不会同步到 attribute 上，即不会反应到 html 上(除以下几种情况，非自定义属性 在二者之间是同步的)。 21、DOM 和 BOM 的区别1、BOM 1.1) BOM 是 Browser Object Model 的缩写，即浏览器对象模型。 1.2） BOM 没有相关标准。 1.3） BOM 的最根本对象是 window 2、DOM 2.1） DOM 是 Document Object Model 的缩写，即文档对象模型。 2.2） DOM 是 W3C 的标准。 2.3） DOM 最根本对象是 document（实际上是 window.document） 22、如何最小化重绘(repaint)和回流(reflow)重绘:当元素的一部分属性发生改变，如外观、背景、颜色等不会引起布局变化，只需要浏览器根据元素的新属性重新绘制，使元素呈现新的外观叫做重绘。 重排（回流）:当 render 树中的一部分或者全部因为大小边距等问题发生改变而需要 DOM 树重新计算的过程 。 重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置） 方法： 1、需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示 2、需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document 缓存 Layout 属性值，如：var left &#x3D; elem.offsetLeft; 这样，多次使用 left 只产生一次回流 。 3、尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流） 4、避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 5、尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 6、批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx 23、EventLoop 事件循环机制什么是 Event Loop JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码 script，setTimeout，setInterval 微任务：Promise.then(非 new Promise)，process.nextTick(node 中) 事件的执行顺序——先执行微任务，然后执行宏任务，任务有同步的任务和异步的任务， 同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后 24、判断一个字符串中出现次数最多的字符，统计这个次数var str = &quot;asdfssaaasasasasaa&quot;; var json = &#123;&#125;; for (var i = 0; i &lt; str.length; i++) &#123; if (!json[str.charAt(i)]) &#123; json[str.charAt(i)] = 1; &#125; else &#123; json[str.charAt(i)]++; &#125; &#125; var iMax = 0; var iIndex = &quot;&quot;; for (var i in json) &#123; if (json[i] &gt; iMax) &#123; iMax = json[i]; iIndex = i; &#125; &#125; alert(&quot;出现次数最多的是:&quot; + iIndex + &quot;出现&quot; + iMax + &quot;次&quot;); 25、将数字 12345678 转化成 RMB 形式 如： 12,345,678//思路：先将数字转为字符， str= str + &#39;&#39; ; //利用反转函数，每三位字符加一个 &#39;,&#39;最后一位不加； re()是自定义的反转函数，最后再反转回去！ for (var i = 1; i &lt;= re(str).length; i++) &#123; tmp += re(str)[i - 1]; if (i % 3 == 0 &amp;&amp; i != re(str).length) &#123; tmp += &quot;,&quot;; &#125; &#125; 26、谈谈你对 Javascript 垃圾回收机制的理解？1、标记清除（mark and sweep） 这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量， 垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离 开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被 环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 2、引用计数(reference counting) 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该 变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以 将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间 在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过 引用计数回收垃圾的，也就是说只要涉及 BOM 及 DOM 就会出现循环引用问题. 27、什么是 Ajax，Ajax 的原理，Ajax 都有哪些优点和缺点？什么是 Ajax Ajax 是“Asynchronous JavaScript and XML”的缩写。他是指一种创建交互式网页应用的网页 开发技术。沟通客户端与服务器，可以在不必刷新整个浏览器的情况下，与服务器进 行 异步通讯的技术 Ajax 的原理 通过 XMLHTTPRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。 XMLHTTPRequest 是 Ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求的 技术。 简单的说，也就是 javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。 达到无刷新的效果。 Ajax 的优点 1、最大的一点是页面无刷新，用户的体验非常好。 2、使用异步方式与服务器通信，具有更加迅速的响应能力。 3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理， 减 轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，Ajax 的原则是“按 需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 Ajax 的缺点 1、Ajax 不支持浏览器 back 按钮。 2、安全问题 Ajax 暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 28、常见的 HTTP 状态码以及代表的意义100 &#x3D;&gt; 正在初始化（一般是看不到的） 101 &#x3D;&gt; 正在切换协议（websocket 浏览器提供的） 202 &#x3D;&gt; 表示接受 301 &#x3D;&gt; 永久重定向&#x2F;永久转移 302 &#x3D;&gt; 临时重定向&#x2F;临时转移（一般用来做服务器负载均衡） 304 &#x3D;&gt; 本次获取的内容是读取缓存中的数据，会每次去服务器校验 401 &#x3D;&gt; 未认证，没有登录网站 403 &#x3D;&gt; 禁止访问，没有权限 502 &#x3D;&gt; 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 503 &#x3D;&gt; 服务器超负荷（假设一台服务器只能承受 10000 人，当第 10001 人访问的时候， 如果服务器没有做负载均衡，那么这个人的网络状态码就是 503） 505 &#x3D;&gt; 服务器不支持请求的 HTTP 协议的版本，无法完成处理。 29、请解释一下 JavaScript 的同源策略同源策略是客户端脚本的重要的安全度量标准。其目的是防止某个文档或脚本从多个不同 源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能 读取来自同一来源的窗口和文档的属性。 30、为什么会有跨域的问题出现，如何解决跨域问题什么是跨域 指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript 施加的安全限制，防止他人恶意攻击网站。 解决方案 jsonp cors 反向代理 31、Get 和 Post 的区别以及使用场景区别 1、Get 使用 URL 或 Cookie 传参。而 Post 将数据放在 body 中 2、Get 的 URL 会有长度上的限制，则 Post 的数据则可以非常大 3、Post 比 Get 安全，因为数据在地址栏上不可见 最本质的区别 基于 http 协议进行请求， 其实 GET 和 POST 无区别， 只是请求时的方式不同， 都可以携 带请求体， 也可以在 URL 带参数 区别来自于浏览器对 URL 长度的限制， 请求体大小来源于服务器的限制 还有语义的区别： GET 是获取， POST 是提交 Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据 Get&#x2F;Post 使用场景 若符合下列任一情况，则 Post 方法： 1、请求的结果有持续性的作用，例如：数据库内添加新的数据行 2、若使用 Get 方法，则表单上收集的数据可能让 URL 过长 3、要传送的数据不是采用 ASCII 编码 若符合下列任一情况，则用 Get 方法： 1、请求是为了查找资源，html 表单数据仅用来搜索 2、请求结果无持续性的副作用 3、收集的数据及 html 表单内的输入字段名称的总长不超过 1024 个字符 32、HTTP 与 HTTPS 的区别1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。 2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。 3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443 4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。) 33、localStorage、sessionStorage、cookie 的区别共同点：都是保存在浏览器端、且同源的 区别： 1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下 2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大 3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭 4、作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。 34、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？1、浏览器查找域名对应的 IP 地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器) 2、浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手） 3 服务器 301 重定向（从 HTTP:&#x2F;&#x2F;example.com 重定向到 HTTP:&#x2F;&#x2F;www.example.com） 4、浏览器跟踪重定向地址，请求另一个带 www 的网址 5、服务器处理请求（通过路由读取资源） 6、服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text&#x2F;html’） 7、浏览器进 DOM 树构建 8、浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS 等） 9、浏览器显示完成页面 10、浏览器发送异步请求 35、HTTP 常见请求方式有哪些？1、GET 请求指定的页面信息，并返回实体主体。 2、HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 3、POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。 4、PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5、DELETE 请求服务器删除指定的页面。 6、CONNECT HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7、OPTIONS 允许客户端查看服务器的性能。 8、TRACE 回显服务器收到的请求，主要用于测试或诊断。 9、PATCH 实体中包含一个表，表中说明与该 URI 所表示的原内容的区别。 10、MOVE 请求服务器将指定的页面移至另一个网络地址。 11、COPY 请求服务器将指定的页面拷贝至另一个网络地址。 12、LINK 请求服务器建立链接关系。 13、UNLINK 断开链接关系。 14、WRAPPED 允许客户端发送经过封装的请求。 15、LOCK 允许用户锁定资源，比如可以再编辑某个资源时将其锁定，以防别人同时对其进行编辑。 16、MKCOL 允许用户创建资源 17、Extension-mothed 在不改动协议的前提下，可增加另外的方法。 36、什么是 TCP 连接的三次握手TCP 是因特网中的传输层协议，使用建立连接，完成三次握手，与服务器开始传送。 第一次握手：建立连接时，发送包（syn&#x3D;j）到服务器，并进入等待状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器 第二次握手：收到 SYN 包，必须确认客户的 SYN（syn&#x3D;j+1），同时自己也发送一个 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入等待状态； 第三次握手：客户端收到服务器器的 SYN+ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入（TCP 连接成功）状态，完成三次握手。 37、为什么 TCP 连接需要三次握手四次挥手为什么是三次握手 为了防止已失效的连接请求报文段突然有送到了服务器，因而产生错误,假设两次握手时， 客户发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达服务器。服务器收到失效的连接请求报文段后，认为是客户又发出一次新的连接请求。于是向客户发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致服务器的资源白白浪费。 为什么是四次挥手 TCP 协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接 是双方都需要确认的共同行为，假设是三次挥手时，首先释放了客户到服务器方向的连接，此时 TCP 连接处于半关闭状态，这时客户不能向服务器发送数据，而服务器还是可以向客户发送数据。如果此时客户收到了服务器的确认报文段后，就立即发送一个确认报文段，这会导致服务器向客户还在发送数据时连接就被关闭。这样会导致客户没有完整收到服务器所发的报文段。 38、ES5 和 ES6 的区别，说几个 ES6 的新增方法ES5 和 ES6 的区别 ECMAScript5，即 ES5，是 ECMAScript 的第五次修订，于 2009 年完成标准化 ECMAScript6，即 ES6，是 ECMAScript 的第六次修订，于 2015 年完成，也称 ES2015 ES6 是继 ES5 之后的一次改进，相对于 ES5 更加简洁，提高了开发效率 ES6 的新增方法 1、新增声明命令 let 和 const 在 ES6 中通常用 let 和 const 来声明，let 表示变量、const 表示常量 1.1）特点 let 和 const 都是块级作用域。以{}代码块作为作用域范围 只能在代码块里面使用不存在变量提升，只能先声明再使用，否则会报错。语法上，称为“暂时性死区” 在同一个代码块内，不允许重复声明 const 声明的是一个只读常量，在声明时就需要赋值。（如果 const 的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而变量成员是可以修改的。） 2、模板字符串（Template String） 用一对反引号(&#96;)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以在字符串中嵌入变量，js 表达式或函数，变量、js 表达式或函数需要写在${ }中。 3、函数的扩展 3.1）函数的默认参数 ES6 为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 3.2）箭头函数 在 ES6 中，提供了一种简洁的函数写法，我们称作“箭头函数”。 39、var、let、const 之间的区别区别 var 声明变量可以重复声明，而 let 不可以重复声明 var 是不受限于块级的，而 let 是受限于块级 var 会与 window 相映射（会挂一个属性），而 let 不与 window 相映射 var 可以在声明的上面访问变量，而 let 有暂存死区，在声明的上面访问变量会报错 const 声明之后必须赋值，否则会报错 const 定义不可变的量，改变了就会报错 const 和 let 一样不会与 window 相映射、支持块级作用域、在声明的上面访问变量会报错 40、介绍下 Set、Map 的区别区别 应用场景 Set 用于数据重组，Map 用于数据储存 Set： 成员不能重复 只有键值没有键名，类似数组 可以遍历，方法有 add, delete,has Map: 本质上是健值对的集合，类似集合 可以遍历，可以跟各种数据格式转换 41、setTimeout、Promise、Async&#x2F;Await 的区别事件循环中分为宏任务队列和微任务队列 宏任务（macrotask）：在新标准中叫 task 主要包括：script(整体代码)，setTimeout，setInterval，setImmediate，I&#x2F;O，ui rendering 微任务（microtask）：在新标准中叫 jobs 主要包括：process.nextTick， Promise，MutationObserver（html5 新特性） setTimeout、Promise、Async&#x2F;Await 的区别 setTimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行 Promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行 async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式 async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 42、Promise 有几种状态，什么时候会进入 catch？Promise 有几种状态 三个状态：pending、fulfilled、reject 两个过程：padding -&gt; fulfilled、padding -&gt; rejected Promise 什么时候会进入 catch 当 pending 为 rejected 时，会进入 catch 43、git 的基本使用方法第一步：window 本机电脑安装 git 软件（只需要一次） 第二步：配置环境变量（只需要一次） 安装到 D:\\software\\git\\目录，把 bin 目录路径完整加入 Path 变量。 D:\\software\\git\\bin 第三步：配置 git 的 config（只需要一次） git config –global user.email “&#121;&#x6f;&#117;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;“ git config –global user.name “Your Name” 查看你的配置是 git config –list 第四步：使用 git 开始工作 （每次） 1 、在本地建立一个文件夹，作为本地代码仓库，并初始化 cmd 中 cd 到该文件夹，执行 git init 命令，让该文件夹成为受 git 管理的仓库目录。 2、把某个文件添加到本地仓库（前提项目文件夹有这个文件） 执行 git add HelloWorld.html 命令 如果暂存所有（git add .） 3、提交文件到仓库 git commit -m “第一次使用 git 提交文件”m 后面的“” 44、git 工作流程git 的作用 1、在工作目录中修改某些文件 2、对修改后的文件进行快照，然后保存到暂存区域 3、提交更新，将保存在暂存区域的文件快照永久转储到 git 目录中 git 的工作中使用场景： 两个分支 master 和 dev 项目开始执行流程 git branch -a (查看所有分支) 0、克隆代码 git clone 地址 1、拉取线上 master 最新代码: git pull origin master 2、切换到开发分支: git checkout dev 3、合并 master 本地分支（master）: git merge master 4、开始开发 5、开发结束 6、查看当前文件更改状态: git status 7、把所有更改代码放到缓存区: git add -A 8、查看当前文件更改状态 : git status 9、缓存区内容添加到仓库中: git commit -m ‘本次更改注释’ 10、把代码传到 gitLab 上: git push origin dev 11、若代码到达上线标准则合并代码到 master,切换分支到 master: git checkout master 12、拉取 master 最新分支: git pull origin master 13、合并分支代码到 master(若有冲突则解决冲突): git merge dev 14、把当前代码上传到 gitLab: git push origin master 15、代码上线后，用 tag 标签标记发布结点(命名规则：prod*+版本*+上线日期) git tag -a prod_V2.1.8_20220201 16、tag 标签推到 gitLab git push origin prod_V2.1.8_20220201 缓存区的应用 1、需要合并别人代码进来 1.1）把自己的代码放入暂存: git stash 1.2）如果需要释放出来用: git stash pop#恢复最近一次的暂存 1.3）查看你有哪些队列: git stash list 1.4）删除第一个队列，以此可以类推: git stash drop stash@{0} 2、需要切换分支 2.1）git add -A 2.2）git stash save ‘demo’ 2.3）git stash list 2.4）git stash apply stash@{0} 45、提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的冲突是如何产生 开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。 如何解决冲突 1、发生冲突，在 IDE 里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。 2、发生冲突，也可以使用命令 通过 git stash 命令，把工作区的修改提交到栈区，目的是保存工作区的修改； 通过 git pull 命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突； 通过 git stash pop 命令，把保存在栈区的修改部分合并到最新的工作空间中； 分支提交冲突：当分支对某文件某句话进行修改后，切换到主分支也对该文件该句话进行修改，使用 git merge 进行合并，需要将两个修改进行合并。此时合并产生冲突 。 3、另外一种解决方法 3.1）git status 查看冲突文件 3.2）编辑器打开冲突文件，查看内容。Git 用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标 记出不同分支的内容 3.3）修改文件内容 3.4）提交 git add file ; git commit -m “” 查看分支合并图 git log –graph 46、什么是 WebpackWebpack 是一个打包模块化 javascript 的工具，在 Webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，Webpack 专注构建模块化项目，Webpack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。 47、有哪些常见的 Loader？他们是解决什么问题的？1、file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 2、url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内 容注入到代码中去 3、source-map-loader：加载额外的 Source Map 文件，以方便断点调试 4、image-loader：加载并且压缩图片文件 5、babel-loader：把 ES6 转换成 ES5 6、css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 7、style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS 8、eslint-loader：通过 ESLint 检查 JavaScript 代码 48、Vue 的最大的优势是什么Vue 作为一款轻量级框架、简单易学、 数据绑定、组件化、数据和结构的分离、虚拟 DOM、运行速度快，并且作者是中国人尤雨溪，对应的 API 文档对国内开发者优化，作为前端开发人员的首选入门框架，Vue 有很多优势： Vue.js 可以进行组件化开发，使代码编写量大大减少，读者更加易于理解。 Vue.js 最突出的优势在于可以对数据进行双向绑定。 相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页面。 Vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom， 这样大大加快了访问速度和提升用户体验。 而且他的第三方 UI 组件库使用起来节省很多开发时间，从而提升开发效率。 49、mvvm 和 mvc 区别是什么？1）MVVM 基本定义 MVVM 即 Model-View-ViewModel 的简写。即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向： 一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页 面。实现的方式是：数据绑定。 二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。 2） MVC 基本定义 MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑。 使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。MVC 和 MVVM 的区别并不是 VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。 50、Vue 数据双向绑定的原理是什么Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 51、Object.defineProperty 和 Proxy 的区别1）Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等 等是 Object.defineProperty 不具备的； Proxy 返 回 的 是 一 个 新 对 象 , 我 们 可 以 只 操 作 新 的 对 象 达 到 目 的 , 而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，新标准的性能红利； 2）Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。 52、请说下封装 Vue 组件的过程首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 1）分析需求：确定业务需求，把页面中可以服用的结构，样式以及功能，单独抽离成一个文件，实现复用。 2）具体步骤： 使用 Vue.component 方法注册组件，子组件需要数据，可以在 props 中接受定义，而子组件修改好数据后，想把数据传递给父组件。可以采用$emit 方法向外抛数据 。 如果需要给组件传入模板，则定义为插槽 slot 如果需要 父组件主动调用子组件的方法 可以在 methods 选项中开放方法 53、组件中写 name 选项有什么作用？1、 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤 2、 DOM 做递归组件时需要调用自身 name 3、Vue-devtools 调试工具里显示的组见名称是由 Vue 中组件 name 决定的 54、watch、methods 和 computed 的区别?1）基本说明 1．computed： 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 2．methods： methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 3．watch： 观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式， 值是对应回调函数。值也可以是方法名，或者包含选项的对象，Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 2）三者的加载顺序 computed 是在 HTML DOM 加载后马上执行的，如赋值；（属性将被混入 到 Vue 实例） methods 则必须要有一定的触发条件才能执行，如点击事件 watch 呢？它用于观察 Vue 实例上的数据变动。 3）默认加载的时候 先 computed 再 watch，不执行 methods； 4）触发某一事件后 先 computed 再 methods 再到 watch computed 属性 vs method 方法 computed 计算属性是基于它们的依赖进行缓存的。 55、Vue 中 key 值的作用是什么？​ 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用” 策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的 顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM。 56、Vuex 的 5 个核心属性是什么?分别是 State、 Getter、Mutation 、Action、 Module 1）state state 为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在 Vue.js 的组件中才能获取你定义的这个对象的状态。 2）getter getter 有点类似 Vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getter，getter 会接收 state 作为第一个参数，而且 getter 的返回值会根据它的依赖被缓存起来，只有 getter 中的依赖值（state 中的某个需要派生状态的值）发生改变的时候才会被重新计算。 3）mutation 更改 store 中 state 状态的唯一方法就是提交 mutation，就很类似事件。每个 mutation 都有一个字符串类型的事件类型和一个回调函数，我们需要改变 state 的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。 4）action action 可以提交 mutation，在 action 中可以执行 store.commit，而且 action 中可以有任何的异步操作。在页面中如果我们要嗲用这个 action，则需要执行 store.dispatch 5）module module 其实只是解决了当 state 中很复杂臃肿的时候，module 可以将 store 分割成模块，每个模块中拥有自己的 state、mutation、action 和 getter。 57、简述 Vuex 的数据传递流程当组件进行数据修改的时候我们需要调用 dispatch 来触发 actions 里面的方法。 actions 里面的每个方法中都会 有一个 commit 方法，当方法执行的时候会通过 commit 来触发 mutations 里面的方法进行数据的修改。mutations 里面的每个函数都会有一个 state 参数，这样就可以在 mutations 里面进行 state 的数据修改 ，当数据修改完毕后，会传导给页面。页面的数据也会发生改变。 58、Vue-Router 是干什么的，原理是什么？Vue-Router 是 Vue.js 官方的路由插件，它和 Vue.js 是深度集成的，适合用于构建单页面应用。Vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在 Vue-Router 单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起 url 和页面之间的映射关系。 “更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式： 利用 URL 中的 hash（“#”） 利用 History interface 在 HTML5 中新增的方法 59、Vue-Router 有哪几种路由守卫?全局守卫：beforeEach 后置守卫：afterEach 全局解析守卫：beforeResolve 路由独享守卫：beforeEnter 60、query 和 params 之间的区别是什么？1、query 要用 path 来引入，params 要用 name 来引入 。 2、接收参数时，分别是 this.$route.query.name 和 this.$route.params.name。 61、**$route 和$router 的区别是什么？**$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。 $router 为 VueRouter 的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如 history 对象，经常用的跳转链接就可以用 this.router.push 会往 history 栈中添加一个新的记录。返回上一个 history 也是使用$router.go 方法。 62、Vue 的路由实现模式：hash 模式和 history 模式1）hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取。特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。 2） history 模式：history 采用 HTML5 的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更。 63、Vue2.0 兼容 IE 哪个版本以上吗？不支持 ie8 及以下，部分兼容 ie9 ，完全兼容 10 以上， 因为 Vue 的响应式原理是基于 es5 的 Object.defineProperty(),而这个方法不支持 ie8 及以下。 64、如何对 Vue 首屏加载实现优化?1、把不常改变的库放到 index.html 中，通过 cdn 引入 2、Vue 路由的懒加载 3、不生成 map 文件 4、Vue 组件尽量不要全局引入 5、使用更轻量级的工具库 6、开启 gzip 压缩 7、首页单独做服务端渲染","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-05-29T06:57:39.019Z","updated":"2023-05-29T06:57:39.019Z","comments":true,"path":"2023/05/29/hello-world/","link":"","permalink":"https://eathl.github.io/2023/05/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}